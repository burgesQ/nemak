#+TITLE: nemacs's config (2)
#+AUTHOR: Quentin Burgess (quentin.burgess@frafos.com)
#+DESCRIPTION: Quick summary of tasks for nemacs second gen
#+STARTUP: show2levels
#+OPTIONS: toc:2

Thanks

- [[https://github.com/progfolio/.emacs.d/tree/master][nice helper]]
- [[https://github.com/syl20bnr/spacemacs][spcemacs]] of course
- [[https://github.com/doomemacs/doomemacs][doomecas]] also
- stackoverflow
- DT' youtube videos
- [[https://ianyepan.github.io/posts/emacs-emojis/][nice tuto about emojis]]
- [[https://github.com/mickeynp/ligature.el/wiki#cascadia--fira-code][ligatures official doc]]
- [[https://www.rahuljuliato.com/posts/emacs-tab-bar-groups][better native tab-bar]]
- [[https://howardabrams.com/hamacs/][monster config]]
- [[https://github.com/jeremygooch/jeremacs][less monstruous but still huge]]

* TODO how to use [0/3]

#+begin_example console
$ emacs -q -l ~/repo/perso/nemacs_2/emacs-init.el --init-directory=~/repo/perso/nemacs_2
#+end_example

** TODO install as ~/.emacs
** TODO as systemctl service (aka emacsclient)
** TODO misc
chemacs

* WIP TODOs
:PROPERTIES:
:COOKIE_DATA: todo recursive
:END:
** TODO v1 [7/13] [53%]
:PROPERTIES:
:COOKIE_DATA: todo recursive
:END:
*** DONE early init
*** DONE elpa management
*** DONE key describe (helpful)
*** WIP keybinding
- [ ] migrate global-set-key to :map
- [ ] migrate from :map to :general (+ which key)
*** DONE UI [3/3]
**** DONE dashboard
**** DONE fonts / faces / emojies / ligatures
**** DONE other stuffs (windows, box)
*** WIP magit
*** TODO org
*** TODO claude-el
*** TODO LSP

*** TODO [fly/spell/*]check

* TODO the config [0/9]
:PROPERTIES:
:COOKIE_DATA: todo recursive
:END:
** early-init

emacs 27+ offer the ealy-init, allowing us to speed thing up at start time.

*** header

`early-init.el` header

#+begin_src emacs-lisp
;;; early-init.el --- Early Init File -*- lexical-binding: t; no-byte-compile: t -*-
;;; Code:
#+end_src

*** elpaca tweaks

Since we're using elpaca as our package manager, we add the following to early-init.el to prevent package.el from loading packages, prior to our init file loading.


#+BEGIN_SRC emacs-lisp
;; Do not attempt to load default package manager.
(setq package-enable-at-startup nil)
#+END_SRC

We configure elpaca to download packages per emacs version

#+BEGIN_SRC emacs-lisp
;; elpa dir per emacs version
(setq package-user-dir (locate-user-emacs-file
                        (concat
                         (file-name-as-directory "elpa")
                         emacs-version)))
#+END_SRC

*** speed things up

#+BEGIN_SRC emacs-lisp
;; Skip default.el loading.
(setq inhibit-default-init nil)
;; Do not report native comp async warnings as errors.
(setq native-comp-async-report-warnings-errors nil)
#+END_SRC

Skipping a bunch of regular expression searching in the file-name-handler-alist should improve start time.

#+begin_src emacs-lisp
;; skipping bunch of regex at start time
(defvar default-file-name-handler-alist
  file-name-handler-alist)
(setq file-name-handler-alist nil)
#+end_src

*** debug

Running this form will launch the debugger after loading a package.
This is useful for finding out when a dependency is requiring a package
(perhaps earlier than you want).
Use by tangling this block and launching Emacs with emacs --debug-init.

#+begin_src emacs-lisp
;; (unless (string-empty-p file)
;;   (eval-after-load file
;;     '(debug)))
#+end_src

Similarly, this variable will hit the debugger when a message matches its regexp.

#+begin_src emacs-lisp
;; (setq debug-on-message "")
#+end_src

Adding a variable watcher can be a useful way to track down initialization and mutation of a variable.

#+begin_src emacs-lisp
;; (add-variable-watcher 'org-capture-after-finalize-hook
;;                       (lambda (symbol newval operation where)
;;                         (debug)
;;                         (message "%s set to %s" symbol newval)))

;; (setq debug-on-error t)
#+end_src

*** gbc tweak

`gc-cons-threshold` (800 KB) and `gc-cons-percentage` (0.1) control when the Emacs garbage collector can kick in. Temporarily turning these off during init should decrease startup time. Resetting them afterward will ensure that normal  operations don’t suffer from a large GC periods.

The following is a table shows values from popular Emacs configurations.

| Distribution | gc-cons-threshold |
|--------------+-------------------|
| Doom         |          16777216 |
| Spacemacs    |         100000000 |
| Default      |            800000 |

#+BEGIN_SRC emacs-lisp
;; tmp disable GC for startup, then re-activating it
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 1)

(defun +nemacs/gc-after-focus-change ()
  "Run GC when frame loses focus."
  (run-with-idle-timer
   5 nil
   (lambda () (unless (frame-focus-state) (garbage-collect)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun +nemacs/better-init-values ()
  "Set GC value to some sensitive one."
  (run-with-idle-timer
   1 nil
   (lambda ()
     (setq file-name-handler-alist default-file-name-handler-alist
           gc-cons-threshold 50000000
           read-process-output-max (* 1024 1024)
           gc-cons-percentage 0.2)
     (message "gc-cons-threshold & file-name-handler-alist restored")
     (when (boundp 'after-focus-change-function)
       (add-function :after after-focus-change-function #'+nemacs/gc-after-focus-change))
     )))

;; enable gbc msg
(setq garbage-collection-messages t)

(add-hook 'emacs-startup-hook #'+nemacs/better-init-values)
#+END_SRC

*** UI tweaks

Modify GUI elements before we have a chance to peek.


Turning off these visual elements before UI initialization should speed up init.

#+BEGIN_SRC emacs-lisp
;; disables menubar
(push '(menu-bar-lines . 0) default-frame-alist)
;; disables toolbar
(push '(tool-bar-lines . 0) default-frame-alist)
;; disables vertical scrollbar
(push '(vertical-scroll-bars) default-frame-alist)
#+END_SRC

Prevent instructions on how to close an emacsclient frame.

#+BEGIN_SRC emacs-lisp
(setq server-client-instructions nil)
#+END_SRC

Implicitly resizing the Emacs frame adds to init time. Fonts larger than the system default can cause frame resizing, which adds to startup tim.e

#+BEGIN_SRC emacs-lisp
(setq frame-inhibit-implied-resize t)
#+END_SRC

Ignore X resources.

#+BEGIN_SRC emacs-lisp
(advice-add #'x-apply-session-resources :override #'ignore)
#+END_SRC

Silence ring bell.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function #'ignore)
#+END_SRC

Lets tune the UI to something more minimal.

#+BEGIN_SRC emacs-lisp
;; enable smooth scrolling
(pixel-scroll-precision-mode 1)
;; disables menubar
(menu-bar-mode -1)
;; disables toolbar
(tool-bar-mode -1)
;; disables scrollbar
(scroll-bar-mode -1)
;; Disable tooltips
(tooltip-mode -1)
;; Give some breathing room
(set-fringe-mode 10)
;; Set up the visible bell


(setq
 ;; no thanks
 inhibit-splash-screen t
 ;; don't use system file dialog
 use-file-dialog nil
 ;; don't show new tab button
 tab-bar-new-button-show nil
 ;; don't show tab close button
 tab-bar-close-button-show nil
 ;; don't show tab close button
 tab-line-close-button-show nil
)
#+END_SRC

Let's tune the system windows.

#+BEGIN_SRC emacs-lisp
;; undecorate windows
;; this should be called before toggle-frame-maximized
(set-frame-parameter nil 'undecorated t)
(set-frame-parameter nil 'internal-border-width 0)
(add-to-list 'default-frame-alist '(undecorated . t))
(add-to-list 'default-frame-alist '(internal-border-width . 0))
#+END_SRC

Set a few fonts.

#+BEGIN_SRC emacs-lisp
;; Set fonts.
(push '(font . "Fira Code Retina") default-frame-alist)
(set-face-font 'default "Fira Code Retina")
(set-face-font 'variable-pitch "Fira Code Retina")
(copy-face 'default 'fixed-pitch)
;; NOTE: needed for emacsclient - fix reduced font size
(add-to-list 'default-frame-alist '(font . "Fira Code Retina"))
#+END_SRC

And start as a maximized window.

Taken from this [[https://emacsredux.com/blog/2020/12/04/maximize-the-emacs-frame-on-startup/][essay]], I figured I would start the initial frame automatically in fullscreen, but not any subsequent frames (as this could be part of the capturing system).

#+BEGIN_SRC emacs-lisp
;; Start as maximized window. (old implem)
;; (unless (frame-parameter nil 'fullscreen)
;;   (toggle-frame-maximized))
;; (add-to-list 'default-frame-alist '(fullscreen . maximized))


(add-to-list 'initial-frame-alist '(fullscreen . maximized))

#+END_SRC

But when capturing, I subsequently open smaller frames that shouldn’t be odd looking:

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
(add-to-list 'default-frame-alist '(ns-appearance . dark))
(add-to-list 'default-frame-alist '(undecorated-round . t))
#+end_src

*** let's "provide" the early init

#+BEGIN_SRC emacs-lisp
(provide 'early-init)
;;; early-init.el ends here
#+END_SRC

** TODO config [0/8]
*** init.el header

#+begin_src emacs-lisp
;;; init.el --- Personal configuration file -*- lexical-binding: t; no-byte-compile: t; -*-
;; NOTE: init.el is generated from init.org.  Please edit that file instead
#+end_src

*** package manager
**** elpaca

Let's install elpaca.
See the [[https://github.com/progfolio/elpaca#installer][repo instructions]] for more.

#+begin_src emacs-lisp
;;
;; Package manager (elpaca)
;;

(defvar elpaca-installer-version 0.11)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1 :inherit ignore
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (<= emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                  ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                  ,@(when-let* ((depth (plist-get order :depth)))
                                                      (list (format "--depth=%d" depth) "--no-single-branch"))
                                                  ,(plist-get order :repo) ,repo))))
                  ((zerop (call-process "git" nil buffer t "checkout"
                                        (or (plist-get order :ref) "--"))))
                  (emacs (concat invocation-directory invocation-name))
                  ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                        "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                  ((require 'elpaca))
                  ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (let ((load-source-file-function nil)) (load "./elpaca-autoloads"))))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+end_src

Let's also setup the ``use-package`` macro.

#+begin_src emacs-lisp
;; Install a package via the elpaca macro
;; See the "recipes" section of the manual for more details.
;; (elpaca example-package)

;; Install use-package support
(elpaca elpaca-use-package
  ;; Enable use-package :ensure support for Elpaca.
  (elpaca-use-package-mode))

;; Set default ``:ensure`` to `(:wait t)
;; (setq use-package-always-ensure t)

;;When installing a package used in the init file itself,
;;e.g. a package which adds a use-package key word,
;;use the :wait recipe keyword to block until that package is installed/configured.
;;For example:
;;(use-package general :ensure (:wait t) :demand t)

;;Turns off elpaca-use-package-mode current declaration
;;Note this will cause evaluate the declaration immediately. It is not deferred.
;;Useful for configuring built-in emacs features.
;; (use-package emacs
;;   :ensure nil
;;   :config (setq ring-bell-function #'ignore))


;; NOTE: current config tell elpaca to load package **after** emacs init.
;; the following will "lazy-load" a package installation
;; (use-package s :ensure (:wait t))
;; while  adding :demand t will enfore it's installation

(setq custom-file (expand-file-name "init.el" user-emacs-directory))
(add-hook 'elpaca-after-init-hook (lambda () (load custom-file 'noerror)))
#+end_src

And the use-feature one

#+begin_src emacs-lisp
(defmacro use-feature (name &rest args)
  "`use-package' for packages which do not require installation.
  See `use-package' for NAME and ARGS."
  (declare (indent defun))
  `(use-package ,name
     :ensure nil
     ,@args))
#+end_src

*** emacs defaults

#+begin_src emacs-lisp
;;Note this will cause evaluate the declaration immediately. It is not deferred.
;;Useful for configuring built-in emacs features.
(use-package emacs
  :ensure nil
  :demand t
  :config
  ;;Turns off elpaca-use-package-mode current declaration
  (setq ring-bell-function #'ignore)
  ;; Open symlink w/o  confirmation prompt.
  (setq vc-follow-symlinks t)
  ;; Load zsh alias
  (setq shell-command-switch "-ic")
  ;; set tab to 4 spaces width
  (setq-default tab-width 4)
  ;; always insert space
  (setq-default indent-tabs-mode nil)

  ;; Backup (aka ~/.#)
  ;; Delete excess backup versions silently
  (setq delete-old-versions -1)
  ;; make backups file even when in version controlled dir
  (setq vc-make-backup-files t)
  ;; which directory to put backups file
  (setq backup-directory-alist `(("." . "~/.emacs.d/backups")) )
  ;; transform backups file name
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)) )

  ;; use utf-8 by default
  (setq coding-system-for-read 'utf-8 )
  (setq coding-system-for-write 'utf-8 )
  ;; sentence SHOULD end with only a point.
  (setq sentence-end-double-space nil)

  (setq create-lockfiles nil) ;; no need to create lockfiles
  (setq enable-recursive-minibuffers t)
  (setq sentence-end-double-space nil)
  (defalias 'yes-or-no-p 'y-or-n-p) ;; life is too shor
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit) ;; escape quits everything

  ;; less noise when compiling elisp
  (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
  (setq load-prefer-newer t)

  ;; Hide commands in M-x which don't work in the current mode
  (setq read-extended-command-predicate #'command-completion-default-include-p)

)
#+end_src

*** TODO org

Let's pimp 'org'

#+begin_src emacs-lisp

;;
;; org stuffs
;;

#+end_src

*** WIP keybinding

**** WIP general

Better key-bindings management.
See the [[https://github.com/noctuid/general.el][repo]] for more info.

#+begin_src emacs-lisp
;;
;; Key-Bindings
;;

;; Install general to manage keybinding.
(use-package general
  :ensure (:wait t)
  :demand t
  :config
  (general-auto-unbind-keys)

  ;; Setup M-m as the global leader key.
  (general-create-definer nemacs/leader-keys
    :state '(normal inset visual emacs)
    :keymap 'override
    :prefix "M-m" ;; Set leader.
    :global-prefix "M-m") ;; Access leader in insert mode.

  (nemacs/leader-keys
    "b" '(:ignore t :wk "Buffer")
    "b d"  '(nemacs--kill-current-buffer :wk "Kill current buffer")
    "b b" '(switch-to-buffer :wk "Switch buffer")
    "b i" '(ibuffer :wk "Ibuffer")
    "b k" '(kill-this-buffer :wk "Kill this buffer")
    "b M" '((lambda () (interactive) (switch-to-buffer "*Messages*"))
            :wk "Messages buffer")
    "b n" '(next-buffer :wk "Next buffer")
    "b p" '(previous-buffer :wk "Previous buffer")
    "b r" '(revert-buffer :wk "Reload buffer")
    "b s"  '(scratch-buffer :wk "Scratch buffer"))

  (nemacs/leader-keys
    "c" '(:ignore t :wk "Config")
    "c r" '((lambda () (interactive)
              (elpaca-process-queues)
              (elpaca-wait)
              (load-file "~/repo/perso/nemacs_2/emacs-init.el"))
            ;; another option: "c r" '(restart-emacs :wk "Restart Emacs") + (use-package restart-emacs  :ensure t)
            :wk "Reload emacs config")
    "c o" '((lambda () (interactive) (find-file "~/repo/perso/nemacs_2/init.org"))
            :wk "Open emacs config"))

(nemacs/leader-keys
   "e" '(:ignore t :wk "Evaluate")
   "e b" '(eval-buffer :wk "Evaluate elisp in buffer")
   "e d" '(eval-defun :wk "Evaluate defun containing or after point")
   "e e" '(eval-expression :wk "Evaluate and elisp expression")
   "e l" '(eval-last-sexp :wk "Evaluate elisp expression before point")
   "e r" '(eval-region :wk "Evaluate elisp in region"))

  (nemacs/leader-keys
    "E" '(:ignore t :wk "Error")
    "E b" '((lambda () (interactive) (setq compilations-scroll-output t)) :wk "Errror buffer to bottom")
    "E f" '((lambda () (interactive) (setq compilations-scroll-output 'first-error)) :wk "Errror buffer first error")
  ;;   "E l" '(flycheck-list-errors :wk "List flycheck error")
  ;;   "E t" '(lsp-treemacs-errors-list :wk "List error tree")
    )

  ;; file manipulation
  ;; namespace mostly used by 'sudo-edit' and 'f.el'
  (nemacs/leader-keys
    "f" '(:ignore t :wk "Files")
    )

  ;; file manipulation
  ;; namespace mostly used by 'magit'
  (nemacs/leader-keys
    "g" '(:ignore t :wk "Git")
    )

  ;; goto
  ;; namespace used 'consult-todo' & others
  (nemacs/leader-keys
    "G" '(:ignore t :wk "GoTo")
    )

  ;; help
  ;; namespace mostly used by 'helpful'
  (nemacs/leader-keys
    "h" '(:ignore t :wk "Help"))

  ;; lsp
  (nemacs/leader-keys
    "l" '(:ignore t :wk "LSP"))

  ;; Major mode
  (nemacs/leader-keys
    "m" '(:ignore t :wk "Major mode"))

  (nemacs/leader-keys org-mode-map
    "m" '(:ignore t :wk "Org")
  ;;   "m a" '(org-agenda :wk "Org agenda")
  ;;   "m e" '(org-export-dispatch :wk "Org export dispatch")
  ;;   "m i" '(org-toggle-item :wk "Org toggle item")
  ;;   "m t" '(org-todo :wk "Org todo")
  ;;   "m B" '(org-babel-tangle :wk "Org babel tangle")
  ;;   "m T" '(org-todo-list :wk "Org todo list")
  ;;   "m b" '(:ignore t :wk "Tables")
  ;;   "m b -" '(org-table-insert-hline :wk "Insert hline in table")
  ;;   "m d" '(:ignore t :wk "Date/deadline")
  ;;   "m d t" '(org-time-stamp :wk "Org time stamp")
    )

  ;; (nemacs/leader-keys
  ;;   "p" '(projectile-command-map :wk "Projectile"))

  (nemacs/leader-keys
    "s" '(:ignore t :wk "Spelling")
  ;;   "s b" '(flyspell-buffer :wk "Check buffer")
  ;;   "s d" '(nemacs/fd-switch-dictionary t :wk "Change dictionary")
  ;; "s n" '(flyspell-goto-next-error :wk "Go to next error")
  ;; "s p" '(flycheck-popup-auto-correct-mode :wk "Toggle popup")
  ;;   "s r" '(flyspell-region :wk "Check region")
  ;;   "s s" '(flyspell-correct-at-point :wk "Correct at point")
  ;;   "s t" '(nemacs/flyspell-toggle t :wk "Toggle spell check")
    )

  (nemacs/leader-keys
    "T" '(:ignore t :wk "Theme")
    "T l" '(load-theme :wk "Load theme")
    "T n" '((lambda () (interactive) (load-theme 'doom-one t)) :wk "Load night theme")
    "T d" '((lambda () (interactive) (load-theme 'doom-one-light t)) :wk "Toggle day theme")
    )

  (nemacs/leader-keys
    "t" '(:ignore t :wk "Toggle")
    ;; "t e" '(eshell-toggle :wk "Toggle eshell")
    ;; "t e" '(flycheck-list-errors :wk "Toggle errors list")
    ;;"t e" '(lsp-treemacs-errors-list :wk "Toggle errors list")
    "t L" '(display-fill-column-indicator-mode :wk "Toggle long lines visual limit")
    "t l" '(display-line-numbers-mode :wk "Toggle line numbers")
    ;; "t n" '(neotree-toggle :wk "Toggle neotree file viewer")
    ;; "t s" '(nemacs/flyspell-toggle t :wk "Toggle spell check")
    "t t" '(visual-line-mode :wk "Toggle truncated lines")
    "t T" '(neotree-toggle :wk "Toggle neotree")
    ;; "t z" '(vterm-toggle :wk "Toggle zsh")
    ;; "t z" '(eshell-toggle :wk "Toggle eshell")
    )

  (nemacs/leader-keys
    "w" '(:ignore t :wk "Windows")
    "w <left>" '(nemacs--buf-move-left :wk "Buffer move left")
    "w <down>" '(nemacs--buf-move-down :wk "Buffer move down")
    "w <up>" '(nemacs--buf-move-up :wk "Buffer move up")
    "w <right>" '(nemacs--buf-move-right :wk "Buffer move right")
    )
)
#+end_src

And a few keybindings that doesn't belong to any groups

#+begin_src emacs-lisp
(general-define-key
 ;; "C-x b" '(counsel-switch-buffer :wk "Better file buffer")
 "C-x <down>" '(bs-show :wk "BS show")
 "C-x 1" '(nemacs/toggle-maximize-buffer :wk "Maximize")
 "C-=" '(text-scale-increase :wk "Zoom in")
 "C--" '(text-scale-decrease :wk "Zoom out")
 "<C-wheel-down>" '(text-scale-increase :wk "Zoom in")
 "<C-wheel-up>" '(text-scale-decrease  :wk "Zoom out")

 ;; ctrl+pgup / ctrl+pgdn to change next/prev tab
 "<C-next>" '(tab-bar-switch-to-next-tab :wk "Next tab")
 "<C-prior>" '(tab-bar-switch-to-prev-tab :wk "Previous tab")
 )

;; pres ESC once instead of twice of three times
(global-set-key [escape] 'keyboard-escape-quit)
#+end_src

**** helpful

For contextual information

#+BEGIN_SRC emacs-lisp
;; install an enriched help screen
(use-package helpful
  :ensure (:wait t)
  :demand t
  :after general
  :general
  (nemacs/leader-keys
    "h c" '(helpful-command :wk "helpful command")
    "h f" '(helpful-callable :wk "helpful callable")
    "h h" '(helpful-at-point :wk "helpful at point")
    "h F" '(helpful-function :wk "helpful function")
    "h v" '(helpful-variable :wk "helpful variable")
    "h k" '(helpful-key :wk "helpful key"))
  )
#+END_SRC
**** marginalia

The [[https://github.com/minad/marginalia][marginalia]] package gives a preview of M-x functions with a one line description,
extra information when selecting files, etc. Nice enhancement without learning any new keybindings.

#+begin_src emacs-lisp
(use-package marginalia
  :ensure (:wait t)
  :demand t
  :init
  (setq marginalia-annotators-heavy t)
  :config
  (add-to-list 'marginalia-command-categories '(project-find-file . file))
  (add-to-list 'marginalia-command-categories '(projectile-find-file . file))
  (marginalia-mode))
#+end_src

**** WIP which-key

Which key for helpful emacs

#+BEGIN_SRC emacs-lisp
;; install which-key
(use-package which-key
  :ensure (:wait t)
  :demand t
  :init
  (setq which-key-enable-extended-define-key t)
  (which-key-mode 1) ;;; init is run every time at pre-config aka set var, invoke mode
  :diminish
  :config                ;;; config is run after the mode' loaded (via hook ?)
  (setq which-key-side-window-location 'bottom
        which-key-sort-order #'which-key-key-order
        which-key-allow-imprecise-window-fit nil
        which-key-sort-uppercase-first nil
        which-key-add-column-padding 1
        which-key-max-display-columns nil
        which-key-min-display-lines 6
        which-key-side-window-slot -10
        which-key-side-window-max-height 0.25
        which-key-idle-delay 0.3
        which-key-max-description-length 25
        which-key-allow-imprecise-window-fit nil
        which-key-separator " → " ))

;; document un-documented commonnly used shortcuts
(which-key-add-key-based-replacements
  "C-x P" "Popwin mgmt"
  "C-x t" "Tabs mgmt"
  ;; C-x smth
)
#+END_SRC

*** completion

Generic auto-complete with boosted Ivy + company.

**** company

On-The-Fly typing completion + box

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure (:wait t)
  :demand t
  :defer t
  ;; :after lsp-mode
  :diminish
  :config
  (setq
   ;; don't add any delay before trying to complete thing being typed
   ;; the call/response to gopls is asynchronous so this should have little
   ;; to no affect on edit latency
   company-idle-delay .1
   ;; start completing after a single character instead of 3
   company-minimum-prefix-length 2
   ;; show number
   company-show-numbers t
   ;; align fields in completions
   company-tooltip-align-annotations t)
  :hook
  ;; (lsp-mode . company-mode)
  ;; lang
  (prog-mode . company-mode)
  ;; org, markdown & co
  (text-mode . company-mode))

(global-set-key (kbd "TAB")
                #'company-indent-or-complete-common)

(use-package company-box
  :ensure (:wait t)
  :demand t
  :defer t
  :after company
  :diminish
  :hook (company-mode . company-box-mode))
#+END_SRC

**** counsel

Spread ivy to M-x with [[https://github.com/abo-abo/swiper#counsel][counsel (ivy#counsel)]].

#+begin_src  emacs-lisp
(use-package counsel
  :ensure (:wait t)
  :demand t
  :diminish
  :after general
  :config (counsel-mode)
  :general
  (general-define-key
   "C-x b" '(counsel-switch-buffer :wk "Better file buffer")
   "C-x C-f" '(counsel-find-file :wk "Beffer find file")
   )
  :bind (("M-x" . counsel-M-x)
         :map minibuffer-local-map
         ("C-r" . 'counsel-minibuffer-history)))

(use-package counsel-projectile
  :ensure (:wait t)
  :demand t
  :diminish
  :after projectile
  :config (counsel-projectile-mode))
#+end_src

**** swiper

Enhance Ivy with [[https://github.com/abo-abo/swiper][swiper]].

#+begin_src emacs-lisp
(use-package swiper
  :config
  ;; TODO: add which key
  (global-set-key (kbd "C-s") 'swiper-isearch))
#+end_src

**** smex

Enhance ivy & other with frequently / most used invocation.
See [[https://github.com/nonsequitur/smex][the official repo]] for more.

#+BEGIN_SRC emacs-lisp
(use-package smex
  :ensure (:wait t)
  :demand t
  :after (ivy counsel)
  :config
  (smex-initialize)
)
#+END_SRC

**** ivy

See the [[https://github.com/abo-abo/swiper#ivy][repo (swiper#ivy)]].

#+begin_src emacs-lisp
;; Use 'ivy' instead of 'helm' (default).
(use-package ivy
  ;; :ensure (:wait t)
  :demand t
  :diminish ivy-mode
  ;; TODO: which-key
  :bind
  (
   :map ivy-minibuffer-map
   ("<left>" . ivy-backward-delete-char)
   ;; ("TAB" . ivy-alt-done)
   ;; ("C-l" . ivy-alt-done)
   ;; ("C-j" . ivy-next-line)
   ;; ("C-k" . ivy-previous-line)
   :map ivy-switch-buffer-map
   ("<left>" . ivy-backward-delete-char)
   ;; ("C-k" . ivy-previous-line)
   ;; ("C-l" . ivy-done)
   ;; ("C-d" . ivy-switch-buffer-kill)
   :map ivy-reverse-i-search-map
   ;; ("C-k" . ivy-previous-line)
   ;; ("C-d" . ivy-reverse-i-search-kill)
   ("<left>" . ivy-backward-delete-char))
  :config
  (setq ivy-use-virtual-buffers t
        ivy-count-format "%d/%d ")
  (global-set-key (kbd "C-x b") 'ivy-switch-buffer)
  (ivy-mode 1)
  )

(setq ivy-use-selectable-prompt t)

;; ??
(use-package ivy-prescient
  :ensure (:wait t)
  :demand t
  :init
  (setq prescient-use-char-folding nil) ;; helps with regexp too big errors for long paths
  :config
  (ivy-prescient-mode))
#+end_src

**** ivy-rich

#+begin_src emacs-lisp
(use-package all-the-icons-ivy-rich
  :ensure t
  :after (ivy ivy-rich all-the-icons)
  :init (all-the-icons-ivy-rich-mode 1))

(use-package ivy-rich
  :ensure (:wait t)
  :demand t
  :after (ivy counsel)
  :init  (ivy-rich-mode 1)
  :custom
  (ivy-virtual-abbreviate 'full
                          ivy-rich-switch-buffer-align-virtual-buffer t
                          ivy-rich-path-style 'abbrev)
  :config
  (ivy-set-display-transformer 'ivy-switch-buffer
                               'ivy-rich-switch-buffer-transformer))
#+end_src

*** UI
**** bell

Enable visual bells

#+begin_src emacs-lisp
(setq visible-bell t)
#+end_src

**** doom

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :ensure (:wait t)
  ;; :demand t
  ;; :defer 2
  :init
  (setq
   doom-modeline-minor-modes nil
   doom-modeline-buffer-encoding nil
   doom-modeline-major-mode-color-icon t
   doom-modeline-buffer-state-icon t
   doom-modeline-buffer-modification-icon t
   doom-modeline-lsp-icon t
   ;; Set VCS info max length
   doom-modeline-vcs-max-length 12
   ;; Enable word count
   doom-modeline-enable-word-count t
   ;; Disable time
   doom-modeline-time-icon nil
   ;; Show position %
   doom-modeline-percent-position t)
  (doom-modeline-mode 1)
  :config
  (column-number-mode 1)
  (display-battery-mode)
  :custom
  (doom-modeline-project-detection 'projectile "Use projectile to fetch the project")
  )

;; install nicer theme
;; need to run M-x nerd-icons-install-fonts
(use-package doom-themes
  :ensure (:wait t)
  :demand t
  :config
  ;; Global settings (defaults)
  (setq
   ;; if nil, bold is universally disabled
   doom-themes-enable-bold t
   ;; if nil, italics is universally disabled
   doom-themes-enable-italic t)

  (load-theme 'doom-one t)

  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)
  ;; Enable custom neotree theme (all-the-icons must be installed!)
  ;; (doom-themes-neotree-config)
  ;; or for treemacs users
  (setq doom-themes-treemacs-theme "doom-atom") ; use "doom-colors" for less minimal icon theme
  ;; (doom-themes-treemacs-config)
  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))
#+END_SRC

**** diminish

This package implements hiding or abbreviation of the modeline displays
(lighters) of minor-modes.  With this package installed, you can add
':diminish' to any use-package block to hide that particular mode in the
modeline.

#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure (:wait t)
  :demand t
  :config
  (diminish 'whitespace-mode)
  (diminish 'eldoc-mode)
  (diminish 'abbrev-mode)
  (diminish 'auto-revert-mode)
)
#+END_SRC

**** faces

#+BEGIN_SRC emacs-lisp
;; Set the default face
(set-face-attribute 'default nil
                    :font "Fira Code Retina"
                    :height 120)

;; Set the fixed pitch face
(set-face-attribute 'fixed-pitch nil
                    :font "Fira Code Retina"
                    :height 100)

;; Set the variable pitch face
(set-face-attribute 'variable-pitch nil
                    :font "Fira Code Retina"
                    :height 295 :weight 'regular)
#+END_SRC

***** all-the-icons / dired

Seems [[https://github.com/rainstormstudio/nerd-icons.el][nerd icons]] may be a nice alternative.

#+BEGIN_SRC emacs-lisp
;; Please run M-x all-the-icons-install-fonts
(use-package all-the-icons
  :ensure (:wait t)
  :demand t
  :if (display-graphic-p))

;; (use-package dired-single) --> not found starting 30.0 ?

(use-package all-the-icons-dired
  :ensure (:wait t)
  :demand t
  :hook (dired-mode . (lambda () (all-the-icons-dired-mode t))))

(use-package all-the-icons-completion
  :ensure (:wait t)
  :demand t
  :after (all-the-icons)
  :init (all-the-icons-completion-mode))

(use-package dired-open
  :ensure (:wait t)
  :demand t
  :config
  ;; Doesn't work as expected!
  ;;(add-to-list 'dired-open-functions #'dired-open-xdg t)
  (setq dired-open-extensions '(("png" . "feh")
                                ("mkv" . "mpv"))))

(use-package dired-hide-dotfiles
  :ensure (:wait t)
  :demand t
  :hook (dired-mode . dired-hide-dotfiles-mode))
#+END_SRC

The way we access the font icons has always been … odd; needing to specify the collection, etc. I would like to come up with a better mechanism, so the following function abstracts that as I figure out a better solution.

***** nerd-icons

Used by the `nemacs-features` function ATM.

#+begin_src emacs-lisp
(use-package nerd-icons)

(defun nemacs--font-icons (collection label &rest args)
  "Abstraction over `nerd-icons' project.
LABEL is a short icon description merged with COLLECTION to
identify an icon to use. For instance, 'faicon or 'octicon.

ARGS, a plist, contain the title, sizing and other information.

For instance:
  (font-icons 'faicon \"file\" :title \"File Management\")

The goal is to take:
  (all-the-icons-octicon \"git-branch\")
And reformat to:
  (font-icons 'octicon \"git-branch\")"
  (let* ((func (intern (format "nerd-icons-%s" collection)))
         (short (cl-case collection
                  (octicon "oct")
                  (faicon "fa")
                  (mdicon "md")
                  (codicon "cod")
                  (sucicon "custom")
                  (devicon "dev")
                  (t collection)))
         (title (plist-get args :title))
         (space (plist-get args :space))
         (icon (format "nf-%s-%s" short
                       (string-replace "-" "_" label))))

    ;; With the appropriate nerd-icons function name,
    ;; an expanded icon name, we get the icon string:
    (concat (apply func (cons icon args))
            (cond
             ((and title space) (concat (s-repeat space " ") title))
             (title             (concat " " title))))))

#+end_src

***** ligature

emacs 27+ "nativly" support ligature. See the
[[https://github.com/mickeynp/ligature.el/wiki#cascadia--fira-code][official doc]] for more info.

#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;
;; Ligature support ;;
;;;;;;;;;;;;;;;;;;;;;;

(use-package ligature
  :ensure (:wait t)
  :demand t
  :config
  ;; Enable the "www" ligature in every possible major mode
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable all Cascadia and Fira Code ligatures in programming modes
  (ligature-set-ligatures 'prog-mode
                          '(;; == === ==== => =| =>>=>=|=>==>> ==< =/=//=// =~
                            ;; =:= =!=
                            ("=" (rx (+ (or ">" "<" "|" "/" "~" ":" "!" "="))))
                            ;; ;; ;;;
                            (";" (rx (+ ";")))
                            ;; && &&&
                            ("&" (rx (+ "&")))
                            ;; !! !!! !. !: !!. != !== !~
                            ("!" (rx (+ (or "=" "!" "\." ":" "~"))))
                            ;; ?? ??? ?:  ?=  ?.
                            ("?" (rx (or ":" "=" "\." (+ "?"))))
                            ;; %% %%%
                            ("%" (rx (+ "%")))
                            ;; |> ||> |||> ||||> |] |} || ||| |-> ||-||
                            ;; |->>-||-<<-| |- |== ||=||
                            ;; |==>>==<<==<=>==//==/=!==:===>
                            ("|" (rx (+ (or ">" "<" "|" "/" ":" "!" "}" "\]"
                                            "-" "=" ))))
                            ;; \\ \\\ \/
                            ("\\" (rx (or "/" (+ "\\"))))
                            ;; ++ +++ ++++ +>
                            ("+" (rx (or ">" (+ "+"))))
                            ;; :: ::: :::: :> :< := :// ::=
                            (":" (rx (or ">" "<" "=" "//" ":=" (+ ":"))))
                            ;; // /// //// /\ /* /> /===:===!=//===>>==>==/
                            ("/" (rx (+ (or ">"  "<" "|" "/" "\\" "\*" ":" "!"
                                            "="))))
                            ;; .. ... .... .= .- .? ..= ..<
                            ("\." (rx (or "=" "-" "\?" "\.=" "\.<" (+ "\."))))
                            ;; -- --- ---- -~ -> ->> -| -|->-->>->--<<-|
                            ("-" (rx (+ (or ">" "<" "|" "~" "-"))))
                            ;; *> */ *)  ** *** ****
                            ("*" (rx (or ">" "/" ")" (+ "*"))))
                            ;; www wwww
                            ("w" (rx (+ "w")))
                            ;; <> <!-- <|> <: <~ <~> <~~ <+ <* <$ </  <+> <*>
                            ;; <$> </> <|  <||  <||| <|||| <- <-| <-<<-|-> <->>
                            ;; <<-> <= <=> <<==<<==>=|=>==/==//=!==:=>
                            ;; << <<< <<<<
                            ("<" (rx (+ (or "\+" "\*" "\$" "<" ">" ":" "~"  "!"
                                            "-"  "/" "|" "="))))
                            ;; >: >- >>- >--|-> >>-|-> >= >== >>== >=|=:=>>
                            ;; >> >>> >>>>
                            (">" (rx (+ (or ">" "<" "|" "/" ":" "=" "-"))))
                            ;; #: #= #! #( #? #[ #{ #_ #_( ## ### #####
                            ("#" (rx (or ":" "=" "!" "(" "\?" "\[" "{" "_(" "_"
                                         (+ "#"))))
                            ;; ~~ ~~~ ~=  ~-  ~@ ~> ~~>
                            ("~" (rx (or ">" "=" "-" "@" "~>" (+ "~"))))
                            ;; __ ___ ____ _|_ __|____|_
                            ("_" (rx (+ (or "_" "|"))))
                            ;; Fira code: 0xFF 0x12
                            ("0" (rx (and "x" (+ (in "A-F" "a-f" "0-9")))))
                            ;; Fira code:
                            "Fl"  "Tl"  "fi"  "fj"  "fl"  "ft"
                            ;; The few not covered by the regexps.
                            "{|"  "[|"  "]#"  "(*"  "}#"  "$>"  "^="))
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t)
  )
#+END_SRC

***** emojify

Thanks to that nice [[https://ianyepan.github.io/posts/emacs-emojis/][tuto]].

We've installed apple emoji following that [[https://github.com/samuelngs/apple-emoji-linux][repo]].

We're asking emacs to render symbol w/ apple ttf emoji.
#+begin_src emacs-lisp
(use-package emojify
  :ensure (:wait t)
  :hook
  (text-mode . emojify-mode) ;; bind to text-mode
  :config
  (when (member "Apple Color Emoji" (font-family-list))
    (set-fontset-font
     t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend))

  (setq
   ;; we want all emoji style
   emojify-display-style 'unicode
   emojify-prog-contexts  'both
   emojify-emoji-styles '(unicode github))
  ;; TODO: bind w/ general
  ;; ; override binding in any mode
  ;; (bind-key* (kbd "C-c .") #'emojify-insert-emoji))
)

#+end_src

**** lines/columns

#+BEGIN_SRC emacs-lisp
;; lines numbers & hooks
(column-number-mode)
(global-display-line-numbers-mode t)
;; selectivly disable line numbers for some mode
(dolist (mode '(text-mode-hook
                org-mode-hook
				;; treemacs-mode-hook
                ;; neotree-mode-hook
                term-mode-hook
                dashboard-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda ()
                   (display-line-numbers-mode 0)
                   )))
#+END_SRC

Native to emacs 27.1+. Set indicator to 80 columns.

#+BEGIN_SRC emacs-lisp
;; set 100 col indicator
(setq
 display-fill-column-indicator-column 80
 fill-column 80)

;; selectivly enable visual column limit for some mode.
(dolist (mode '(org-mode-hook
                prog-mode-hook))
  (add-hook mode
            (lambda ()
              (display-fill-column-indicator-mode t)
              )))
#+END_SRC

Highlight text that extends beyond a certain column. See
[[https://github.com/jordonbiondo/column-enforce-mode][here]] for more info.

#+BEGIN_SRC emacs-lisp
(use-package column-enforce-mode
  :ensure (:wait t)
  :diminish
  :hook
  (prog-mode . column-enforce-mode) ;; bind to prog-mode
  (text-mode . column-enforce-mode) ;; bind to text-mode
  :config
  (setq column-enforce-column 100     ;; set highlight past 80 columns
        column-enforce-comments nil) ;; don't highlights comments
  )
#+END_SRC

**** landing dashboard

***** dad jokes
Stolen from [[https://howardabrams.com/hamacs/ha-dashboard.html][here]] - I like the idea :nerd_face:.

#+begin_src emacs-lisp
(use-package request
  :ensure (:wait t)
  :demand t
  :init
  (defvar nemacs-dad-joke nil "Holds the latest dad joke.")

  :config
  (defun nemacs-dad-joke ()
    "Display a random dad joke."
    (interactive)
    (message (nemacs--dad-joke)))

  (defun nemacs--dad-joke ()
    "Return string containing a dad joke from www.icanhazdadjoke.com."
    (setq nemacs-dad-joke nil)  ; Clear out old joke
    (nemacs--dad-joke-request)
    (nemacs--dad-joke-wait))

  (defun nemacs--dad-joke-wait ()
    (while (not nemacs-dad-joke)
      (sit-for 1))
    (unless nemacs-dad-joke
      (nemacs--dad-joke-wait))
    nemacs-dad-joke)

  (defun nemacs--dad-joke-request ()
    (request "https://icanhazdadjoke.com"
      :sync t
      :complete (cl-function
                 (lambda (&key data &allow-other-keys)
                   (setq nemacs-dad-joke data))))))


#+end_src

***** emacs native features

I would appreciate seeing if my Emacs installation has the features that I expect:

#+begin_src emacs-lisp
(defun nemacs-features (&optional non-iconic)
  "Simple display of features I'm most keen about.
  If NON-ICONIC is non-nil, return a string of text only."
  (interactive)

  (defun nemacs--feature-combo (container icon title)
    (nemacs--font-icons container icon :title title :height 1.3 :v-adjust -0.1))

  (defun nemacs--all-images ()
    (s-join "·"
            (-remove 'null
                     (list
                      (when (image-type-available-p 'gif)  "GIF")
                      (when (image-type-available-p 'svg)  "SVG")
                      (when (image-type-available-p 'jpeg) "JPG")
                      (when (image-type-available-p 'tiff) "TIFF")
                      (when (image-type-available-p 'webp) "WEBP")
                      (when (image-type-available-p 'png)  "PNG")))))

  (let* ((features
          (list
           ;; An either or ... at least for me:
           (when (eq (window-system) 'ns)
             (nemacs--feature-combo  'faicon "apple"   "MacOS"))
           (when (eq (window-system) 'pgtk)
             (nemacs--feature-combo  'faicon "xing"    "Gnome"))

           ;; Important to know if I have it:
           (when (and (fboundp 'native-comp-available-p)
                      (native-comp-available-p))
             (nemacs--feature-combo  'faicon "cog"     "Native Compilation"))
           (when (treesit-available-p)
             (nemacs--feature-combo  'faicon "tree"    "Tree Sitter"))
           (when (sqlite-available-p)
             (nemacs--feature-combo  'faicon "database" "Sqlite"))
           (when (gnutls-available-p)
             (nemacs--feature-combo  'faicon "expeditedssl" "TLS"))
           ;; Did we build with mail utilities? Check the command line
           ;; options we used to build Emacs:
           (when (or (string-search "with-mailutils" system-configuration-options)
                     (string-search "without-pop" system-configuration-options))
             (nemacs--feature-combo  'octicon "mail" "GNU Mail"))

           (when (fboundp 'make-xwidget)
             (nemacs--feature-combo  'mdicon "widgets" "XWidgets"))

           ;; This suffix of loadable module files will be nil if
           ;; modules are not supported:
           (when module-file-suffix  ; or (fboundp 'module-load)
             (nemacs--feature-combo 'faicon "th"       "Modules"))

           (when (json-available-p)
             (nemacs--feature-combo  'codicon "json"   "JSON"))
           (when (string-search "HARFBUZZ" system-configuration-features)
             (nemacs--feature-combo  'faicon "font"    "HARFBUZZ"))
           (when (string-search "DBUS" system-configuration-features)
             (nemacs--feature-combo  'faicon "bus"     "DBUS"))
           (nemacs--feature-combo  'faicon "picture-o" (nemacs--all-images))
           (when (fboundp 'imagemagick-types)
             (nemacs--feature-combo  'faicon "magic"   "ImageMagick"))))
         (results (s-join "  " (-remove 'null features))))

    (if (called-interactively-p)
        (message "Enabled features: %s" results)
      results)))
#+end_src

***** dashboard

Nice welcome screen. See the official
[[https://github.com/emacs-dashboard/emacs-dashboard][repo]] for more info.

#+BEGIN_SRC emacs-lisp
(use-package page-break-lines
  :ensure (:wait t)
  :demand t
)

;; nicer welcome screen
(use-package dashboard
  :ensure (:wait t)
  :demand t
  :after (all-the-icons nerd-icons projectile page-break-lines)
  :init
  (defun nemacs-dashboard-version ()
    (let ((smaller-version (replace-regexp-in-string
                            (rx " (" (zero-or-more any) eol) "" (emacs-version))))
      (string-replace "\n" "" smaller-version)))

  ;; Tweak banner logo and title.
  (setq dashboard-banner-logo-title
        (format "Emacs with %s — %s"
                (if (and (fboundp 'native-comp-available-p)
                         (native-comp-available-p))
                    "with Native Compilation" "")
                (nemacs-dashboard-version)))
  ;; Disaply a random "dad joke" as footer message.
  (setq dashboard-footer-messages (list (nemacs--dad-joke)))
  ;; Set dashboard as initial buffer.
  (setq initial-buffer-choice 'dashboard-refresh-buffer)

  ;; horizontally center content
  (setq dashboard-center-content t)
  ;; verically center content
  (setq dashboard-vertically-center-content t)
  ;; enable cycle navigation between each section
  (setq dashboard-navigation-cycle t)

  ;; add icons to the widget headings and their items
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  (setq dashboard-set-navigator t)
  ;; close agenda buffers
  (setq dashboard-agenda-release-buffers t)
  ;; Disaply package & loadtime metrics.
  (setq dashboard-set-init-info t)
  ;; Set projcetile as project backend.
  (setq dashboard-projects-backend 'projectile)

  (setq dashboard-display-icons-p t) ;; use `all-the-icons' package
  (setq dashboard-icon-type 'all-the-icons) ;; use `all-the-icons' package

  ;; FIXME: need counsel (setq dashboard-projects-switch-function 'counsel-projectile-switch-project-by-name)

  (setq dashboard-startup-banner "/home/master/repo/perso/nemacs/logo/aum.xpm")
  (setq dashboard-image-banner-max-width 500)
  (setq dashboard-image-banner-max-height 500)
  (setq dashboard-image-extra-props '(:mask heuristic))

  (setq dashboard-items '(
                          ;; (agenda . 15)
                          (recents . 15)
                          (projects . 15)
                          ;; (bookmarks . 5)
                          ;; (registers . 5)
                          ))

  (setq dashboard-item-shortcuts '(
                                   ;; (agenda    . "a")
                                   (recents   . "r")
                                   (projects  . "p")
                                   ;; (bookmarks . "m")
                                   ;; (registers . "e")
                                   ))

  (setq dashboard-item-names '(("Recent Files:"               . "Recently opened files:")
                               ;; ("Agenda for today:"           . "Today's agenda:")
                               ;; ("Agenda for the coming week:" . "Agenda:")
                               ))

  :when (not command-line-args-left)
  :config
  (dashboard-setup-startup-hook)
  (dashboard-modify-heading-icons '((recents . "file-text")))
  )

(add-hook 'dashboard-mode-hook
            (lambda ()
              (message "opt-in compilation features: %s" (nemacs-features))))
#+END_SRC

**** transparency

Native to emacs29+

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(alpha-background . 90))
#+END_SRC

**** tree

Treemacs again ? Smth else ?


Let's use neotree, nicer than treemacs

#+begin_src emacs-lisp
(use-package neotree
  :ensure (:wait t)
  :demand t
  :config
  (setq neo-smart-open t
        neo-show-hidden-files t
        neo-window-width 25
        neo-window-fixed-size nil
        inhibit-compacting-font-caches t
        projectile-switch-project-action 'neotree-projectile-action)
  ;; truncate long file names in neotree
  (add-hook 'neo-after-create-hook
            #'(lambda (_)
                (with-current-buffer (get-buffer neo-buffer-name)
                  (setq truncate-lines t)
                  (setq word-wrap nil)
                  (make-local-variable 'auto-hscroll-mode)
                  (setq auto-hscroll-mode nil)))))
#+end_src

**** tabs

Native tab ? Or smth better ?

#+begin_src emacs-lisp
(use-feature tab-bar
  :custom
  (tab-bar-close-button-show nil "Dont' show the x button on tabs")
  (tab-bar-new-button-show   nil)
  ;;(tab-bar-show  nil "hide the tab bar. Use commands to access tabs.")
  (tab-bar-tab-hints t)
  (tab-bar-auto-width nil)
  (tab-bar-separator " ")
  (tab-bar-format '(tab-bar-format-tabs-groups
                    tab-bar-format-tabs
                    tab-bar-separator
                    tab-bar-format-add-tab))
  :general
  (general-define-key
    "C-x t b" '(tab-bar-history-back :wk "Backward history tab")
    "C-x t d" '(tab-bar-close-tab :wk "Close tab")
    "C-x t f" '(tab-bar-history-forward :wk "Forward history tab")
    "C-x t g" '(nemacs/tab-switch-to-group :wk "Switch to tab group")
    "C-x t H" '((lambda (arg) (interactive "p") (tab-bar-move-tab (- arg))) :wk "Move tab left")
    "C-x t h" '(tab-bar-switch-to-prev-tab :wk "Switch to previous tab")
    "C-x t l" '(tab-bar-switch-to-next-tab :wk "Switch to next tab")
    "C-x t L" '((lambda (arg) (interactive "p") (tab-bar-move-tab arg)) :wk "Move tab right")
    "C-x t n" '(tab-bar-switch-to-next-tab :wk "Switch to Next tab")
    "C-x t N" '(tab-bar-new-tab :wk "New tab")
    "C-x t p" '(tab-bar-switch-to-prev-tab :wk "Prev tab")
    "C-x t P" '(nemacs/tab-group-from-project :wk "Group tabs per project")
    "C-x t r" '(tab-bar-rename-tab :wk "Rename tab")
    "C-x t t" '(tab-bar-switch-to-tab :wk "Switch to tab")
    "C-x t u" '(tab-bar-undo-close-tab :wk "Undo close tab")
    "C-x t O" '(tab-bar-close-other-tabs :wk "Close Other tabs")
    "C-x t w" '(tab-bar-move-tab-to-frame :wk "Move tab to frame"))
  )

;; First, tab-bar-tab-name-format-hints: I want to put some arrows around the hints number, and NOT show the buffer name.
(defun tab-bar-tab-name-format-hints (name _tab i)
  (if tab-bar-tab-hints (concat (format "»%d«" i) "") name))

(defun tab-bar-tab-group-format-default (tab _i &optional current-p)
  (propertize
   (concat (funcall tab-bar-tab-group-function tab))
   'face (if current-p 'tab-bar-tab-group-current 'tab-bar-tab-group-inactive)))

(defun nemacs/tab-group-from-project ()
  "Call `tab-group` with the current project name as the group."
  (interactive)
  (when-let* ((proj (project-current))
			  (name (file-name-nondirectory
					 (directory-file-name (project-root proj)))))
	(tab-group (format "[%s]" name))))


(add-to-list 'display-buffer-alist
			 '("\\*scratch\\*"
			   (display-buffer-in-tab display-buffer-full-frame)
			   (tab-group . "[EMACS]")))

(defun nemacs/tab-switch-to-group ()
  "Prompt for a tab group and switch to its first tab.
Uses position instead of index field."
  (interactive)
  (let* ((tabs (funcall tab-bar-tabs-function)))
	(let* ((groups (delete-dups (mapcar (lambda (tab)
										  (funcall tab-bar-tab-group-function tab))
										tabs)))
		   (group (completing-read "Switch to group: " groups nil t)))
	  (let ((i 1) (found nil))
		(dolist (tab tabs)
		  (let ((tab-group (funcall tab-bar-tab-group-function tab)))
			(when (and (not found)
					   (string= tab-group group))
			  (setq found t)
			  (tab-bar-select-tab i)))
		  (setq i (1+ i)))))))

;; (custom-set-faces
;;   '(tab-bar
;; 	((t (:background "#232635" :foreground "#A6Accd"))))
;;   '(tab-bar-tab
;; 	((t (:background "#232635" :underline t))))
;;   '(tab-bar-tab-inactive
;; 	((t ( ;; :background "#232635" ;; uncomment to use this
;; 		  ;; :box (:line-width 1 :color "#676E95")
;; 		  ))))
;;   '(tab-bar-tab-group-current
;; 	((t (:background "#232635" :foreground "#A6Accd" :underline t))))
;;   '(tab-bar-tab-group-inactive
;; 	((t (:background "#232635" :foreground "#777")))))

#+end_src

**** window dimmer
#+begin_src emacs-lisp
(use-package dimmer
  :ensure (:wait t)
  :demand t
  :custom
  (dimmer-adjustment-mode :foreground)
  :config
  (dimmer-configure-which-key)    ; Do not dim these special windows
  (dimmer-configure-hydra)
  (dimmer-configure-magit)

  (dimmer-mode t))
#+end_src
*** QoL

**** Prompts

I prefer emacs to just ask y/n not yes/no

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
(setopt use-short-answers t)
#+end_src

**** Shells

Prevent async shell command buffers from popping-up:

#+begin_src emacs-lisp
(add-to-list 'display-buffer-alist
  '("\\*Async Shell Command\\*.*" display-buffer-no-window))
#+end_src

**** Regex

Fix emacs regex

#+begin_src emacs-lisp
(setq-default pcre-mode t)
#+end_src

**** Buffers

Remember where I left off after killing a file

#+begin_src emacs-lisp
(save-place-mode 1)
#+end_src

When killing a buffer always pick the current buffer by default

#+begin_src emacs-lisp
(defun nemacs--kill-current-buffer ()
  "Kills the current buffer."
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'nemacs-kill-current-buffer)
#+end_src

When a file changes on disk, automatically reload its buffer silently

#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+end_src

***** auto-scroll *Compilation* buffer

#+begin_src emacs-lisp
;; scroll compilation buffer to first error
;; (setq compilation-scroll-output 'first-error)

;; scroll compilation buffer to end
(setq compilation-scroll-output t)
#+end_src

***** colored *Compilation* buffer.

#+BEGIN_SRC emacs-lisp
;; color compilation output
(require 'ansi-color)
(defun nemacs/colorize-compilation-buffer ()
  "Colorize the *compilation* buffer output"
  (ansi-color-apply-on-region compilation-filter-start (point)))
(add-hook 'compilation-filter-hook 'nemacs/colorize-compilation-buffer)
#+END_SRC

***** smooth scrolling

#+begin_src emacs-lisp
;; value greater than 100 gets rid of half page jumping
(setq scroll-conservatively 101)
;; how many lines at a time
(setq mouse-wheel-scroll-amount '(3 ((shift) . 3)))
;; accelerate scrolling
(setq mouse-wheel-progressive-speed t)
;; scroll window under mouse
(setq mouse-wheel-follow-mouse 't)
#+end_src

***** move buffer

Creating some functions to allow us to easily move windows (splits) around.  The following block of code was taken from buffer-move.el found on the EmacsWiki:
  https://www.emacswiki.org/emacs/buffer-move.el

#+BEGIN_SRC emacs-lisp
(require 'windmove)

;;;###autoload
(defun nemacs--buf-move-up ()
  "Swap the current buffer and the buffer above the split.
If there is no split, ie now window above the current one, an
error is signaled."
;;  "Switches between the current buffer, and the buffer above the
;;  split, if possible."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'up))
     (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No window above this one")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun nemacs--buf-move-down ()
"Swap the current buffer and the buffer under the split.
If there is no split, ie now window under the current one, an
error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'down))
     (buf-this-buf (window-buffer (selected-window))))
    (if (or (null other-win)
            (string-match "^ \\*Minibuf" (buffer-name (window-buffer other-win))))
        (error "No window under this one")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun nemacs--buf-move-left ()
"Swap the current buffer and the buffer on the left of the split.
If there is no split, ie now window on the left of the current
one, an error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'left))
     (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No left split")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun nemacs--buf-move-right ()
"Swap the current buffer and the buffer on the right of the split.
If there is no split, ie now window on the right of the current
one, an error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'right))
     (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No right split")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))
#+END_SRC
***** maximize buffer

Instead of kill other via X-1. Stollen from spacemacs, sorry mom.

#+BEGIN_SRC emacs-lisp
(defun nemacs/toggle-maximize-buffer ()
  "Maximize buffer"
  (interactive)
  (save-excursion
	(if (and (= 1 (length (window-list)))
			 (assoc ?_ register-alist))
		(jump-to-register ?_)
      (progn
		(window-configuration-to-register ?_)
		(delete-other-windows)))))
#+END_SRC

***** pop-win

popwin is a popup window manager for Emacs which makes you free from the hell of annoying buffers such like *Help*, *Completions*, *compilation*, and etc.

#+BEGIN_SRC emacs-lisp
;; better buffer per name position mgmt
(use-package popwin
  :ensure (:wait t)
  :config
  (popwin-mode 1)
  (setq popwin:special-display-config
        '(
          ;; compilation at bottom
          ("*compilation*" :height 0.4 :noselect t :stick t)
          ;; termnial at bottom
          ("*terminal*" :position top :height 0.3 :noselect t)
          ("*shell*" :position top :height 0.3 :noselect t)
          ;; ("*Compile-Log*" :position bottom :height 0.3 )
          ;; Error right
          )))

(global-set-key (kbd "C-x P") popwin:keymap)
#+END_SRC

***** ominobox

Visual Studio like - see [[https://github.com/sebastiencs/omnibox][here]] for more.

#+BEGIN_SRC emacs-lisp
(use-package omnibox
  :ensure t
  :config
  ;; Disable omnibox-M-x as marginela offer nice completion out of the box.
  ;; (global-set-key (kbd "M-x") 'omnibox-M-x)
  ;; (omnibox-setup)
  )

;; better projectile switch via omnibox UI
(defun omnibox-projectile-switch-project nil
  """Spawn projectile switch project into an omnibox widget."""
  (interactive)
  (omnibox
   :prompt "Projects: "
   :candidates projectile-known-projects
   :action (lambda (candidate)
             (projectile-switch-project-by-name candidate))
   :title "Switch Project: "))

(defun omnibox-projectile-find-file nil
  """Spawn projectile find file into an omnibox widget."""
  (interactive)
  (let* ((omnibox-projectile-project-root (projectile-project-root)))
    (omnibox
     :prompt (format "[%s]: " (projectile-project-name))
     :candidates (projectile-current-project-files)
     :action (lambda (candidate)
               (find-file (expand-file-name candidate omnibox-projectile-project-root)))
     :title "Open File: ")))

;; bind default projectile-find-file to omnibox one
;; (setq projectile-switch-project-action 'omnibox-projectile-find-file)

;; counsel--M-x candidates sourced from source code
;; see https://github.com/abo-abo/swiper/blob/595d44264420d989e420351ea25b3c99528547c0/counsel.el#L856

;; ;; this is a wip
(defun omnibox-counsel-M-x ()
  """Spawm counsel-M-x into an omnibox widget."""
  (interactive)
  (omnibox
   :prompt "M-x: "
   :candidates (counsel--M-x-externs)
   ;; :history extended-command-history
   :detail 'omnibox--function-doc
   :action (lambda (candidate)
             (when candidate
               (counsel-M-x-action candidate)))
  :title "Omnibox counsel M-x"
  :require-match t))

;; (global-set-key (kbd "M-x") 'omnibox-counsel-M-x)
#+END_SRC

***** undo-tree
A better undo system. See the [[https://elpa.gnu.org/packages/undo-tree.html][official doc]] for more.

#+BEGIN_SRC emacs-lisp
;; install a better undo system
(use-package undo-tree
  :ensure t
  :diminish
  :config
  (setq undo-tree-history-directory-alist
        '(("." . "~/.emacs.d/undo")))
  (global-undo-tree-mode))
#+END_SRC

**** Symbols

#+begin_src emacs-lisp
(global-prettify-symbols-mode 1)
#+end_src

**** Boosted string n file manipulation functions

The [[https://github.com/magnars/s.el][s.el]] project is a simpler string manipulation library that I (and other projects) use.

Manipulate file paths with the [[https://github.com/rejeep/f.el][f.el]] project.

#+begin_src emacs-lisp
(use-package s)
(use-package f)
#+end_src

**** Code inlined TODOs highlight-ing

Highlight in-code TODOs

#+begin_src emacs-lisp
(use-package hl-todo
  :ensure (:wait t)
  :hook ((org-mode . hl-todo-mode)
         (prog-mode . hl-todo-mode)
         ;; (yaml-mode . hl-todo-mode)
         ;; (markdown-mode . hl-todo-mode)
         )
  :config
  (setq hl-todo-highlight-punctuation ":"
        hl-todo-keyword-faces
        `(("TODO"  warning bold)
          ("FIXME" error bold)
          ("HACK"  font-lock-constant-face bold)
          ("IDEA"  font-lock-keyword-face bold)
          ("LINK"  success bold)
          ("NOTE"  success bold))))
#+end_src

Suggests to bind some keys to hl-todo-next in order to jump from tag to tag, but the consult-todo implements that in a more visual way:

#+begin_src emacs-lisp
(use-package consult-todo
  :ensure (:wait t)
  :after (general)
  :init
  (defconst consult-todo--narrow
    '((?t . "TODO")
      (?f . "FIXME")
      (?h . "HACK")
      (?i . "IDEA")
      (?l . "LINK")
      (?n . "NOTE")))
  :general
  (nemacs/leader-keys
    "G t" '("GoTo ToDos" . consult-todo))
  )
#+end_src

**** Rainbow delimiters

#+BEGIN_SRC emacs-lisp
;; install rainbow delimites
;; use M-x check-parens for parenthesis error
(use-package rainbow-delimiters
  :ensure (:wait t)
  :diminish
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
**** Rainbow mode

Display the actual color as a background for any hex color value (ex. #ffffff).
The code block below enables rainbow-mode in all programming modes (prog-mode)
as well as org-mode, which is why rainbow works in this document.

#+BEGIN_SRC  emacs-lisp
(use-package rainbow-mode
  :ensure (:wait t)
  :diminish
  :hook
  ((prog-mode org-mode) . rainbow-mode))
#+END_SRC

**** find the bloody cursor

Large screen, lots of windows, so where is the cursor? While I used to use hl-line+,
I found that the prolific Protesilaos Stavrou introduced his Pulsar project is just what I need.
Specifically, I might loose the cursor and need to have it highlighted (using F8),
but also, this automatically highlights the cursor line with specific actions , like changing windows.

I can’t find the cursor, and don’t want to move it to see it, I can hit a key:

#+begin_src emacs-lisp
(use-package pulsar
  :ensure (:wait t)
  :demand t
  :bind ("<f8>" . pulsar-pulse-line)
  :custom
  (pulsar-face 'pulsar-generic)
  (pulsar-delay 0.15)
  :config
  (dolist (built-in-function '(recenter-top-bottom move-to-window-line-top-bottom reposition-window
                               bookmark-jump other-window delete-window delete-other-windows
                               forward-page backward-page scroll-up-command scroll-down-command
                               tab-new tab-close tab-next org-next-visible-heading
                               org-previous-visible-heading org-forward-heading-same-level
                               org-backward-heading-same-level outline-backward-same-level
                               outline-forward-same-level outline-next-visible-heading
                               outline-previous-visible-heading outline-up-heading))
    (add-to-list 'pulsar-pulse-functions built-in-function))
(pulsar-global-mode 1))
#+end_src

**** sudo edit

#+BEGIN_SRC emacs-lisp
;; quickly sudo edit files
(use-package sudo-edit
  :ensure (:wait t)
  :demand t
  :after general
  :general
  (nemacs/leader-keys
    "f u" '(sudo-edit-find-file :wk "Sudo find file")
    "f U" '(sudo-edit :wk "Sudo edit file"))
)
#+END_SRC
*** TODO IDE

**** TODO flycheck / flymake / flyspell & others

Various kind of error reporters.

#+begin_src emacs-lisp

;;
;; claude.el stuffs
;;

#+end_src


***** flycheck

Flycheck is a modern on-the-fly syntax checking extension for GNU Emacs, intended as replacement for the older Flymake extension which is part of GNU Emacs.

https://www.flycheck.org/en/latest/

#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :defer t
  :diminish
  :init
  (global-flycheck-mode)
  :commands (flycheck-mode)
  :custom (flycheck-emacs-lisp-load-path 'inherit "necessary with alternatives to package.el")
;; TODO: general
;; (+general-global-error "l" 'flycheck-list-errors)
  )

#+end_src

**** TODO claude.el

Let's setup 'claude.el'

#+begin_src emacs-lisp

;;
;; claude.el stuffs
;;

#+end_src


**** TODO LSP

Let's setup LSP

#+begin_src emacs-lisp

;;
;; LSP stuffs
;;

#+end_src

***** languages


**** magit


#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;;;;;;
;; magit stuff ;;
;;;;;;;;;;;;;;;;;

(use-package sqlite3
  :ensure (:wait t)
  :demand t)

(defun nemacs/magit-display-buffer-pop-up-frame (buffer)
  "Create or update the magit status dedicated buffer window"
  (if (with-current-buffer buffer (eq major-mode 'magit-status-mode))
      (display-buffer buffer
                      '((display-buffer-reuse-window
                         display-buffer-pop-up-frame)
                        (reusable-frames . t)))
    (magit-display-buffer-traditional buffer)))

;; install magit for git management
(use-package magit
  ;; :ensure (:wait t)
  ;; :demand t
  :after (general)
  :commands (magit-status magit-get-current-branch)
  :custom
  (magit-display-buffer-function #'
   ;; magit-display-buffer-same-window-except-diff-v1)
   nemacs/magit-display-buffer-pop-up-frame)
  :config
  (magit-rebase-commit-arguments '("--format=%h %an %s"))
  (transient-bind-q-to-quit)
  :general
  (nemacs/leader-keys
    "g b"  '(magit-branch :wk "Git branch")
    "g B"  '(magit-blame  :wk "Git blame")
    "g c"  '(magit-clone    :wk "Git clone")
    "g f"  '(:ignore t :which-key "Git file")
    "g f f" '(magit-find-file :wk "Git find file")
    "g f h" '(magit-log-buffer-file :wk "Git log buffer fule")
    "g i"  '(magit-init :wk "Git init")
    "g L"  '(magit-list-repositories :wk "Git list repositories")
    "g m"  '(magit-dispatch :wk "Git dispatch")
    "g S"  '(magit-stage-file :wk "Git stage file")
    "g s"  '(magit-status :wk "Git status")
    "g U"  '(magit-unstage-file :wk "Git unstage file")
    )
)

(use-package magit-todos :after (magit forge))
#+END_SRC

***** forge

Forge allow to fetch extra meta-data from github & gitlab.

See [[https://magit.vc/manual/forge/Token-Creation.html#Token-Creation][token creation]] and [[https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started][getting started]].

TLDR:

#+BEGIN_EXAMPLE console
$ cat .authinfo
machine gitlab.com/api/v4 login [username]^forge password [token]
#+END_EXAMPLE

#+BEGIN_SRC  emacs-lisp
(use-package forge
  ;; :ensure (:wait t)
  ;; :demand t
  :after magit
  :config
  (add-to-list 'forge-alist
               '("gitlab.frafos.net" "gitlab.frafos.net/api/v4"
                 "gitlab.frafos.net" forge-gitlab-repository)))
(setq auth-sources '("~/.authinfo"))
#+END_SRC
>>>>>>> Stashed changes

**** projectile

#+BEGIN_SRC emacs-lisp
;; projects handler
(use-package projectile
  :ensure (:wait t)
  :demand t
  :after (general)
  :diminish
  :config (add-to-list 'projectile-globally-ignored-directories "*node_modules")
  (add-to-list 'projectile-globally-ignored-directories "*vendor")
  (projectile-mode 1)
  :custom ((project-completion-system 'ivy))
  :init
  (when (file-directory-p "~/repo")
    (setq projectile-project-search-path '("~/repo")))
  (setq
   projectile-indexing-method 'alien
   projectile-enable-caching t
   projectile-switch-project-action #'projectile-dired))

(projectile-register-project-type 'go_make '("Makefile" "src" "etc")
                                  ;; :project-file '("Makefile", "src/go.mod" "src/go.sum", "src/vendor")
                                  ;; :compilation-dir "."
                                  :compile "make static"
                                  :configure "make tidy sync rvendor"
                                  ;; :install "make install DESTDIR=`mktemp -d`"
                                  :test "make test TEST_ARGS='-failfast' TEST_TIMEOUT=5s"
                                  :src-dir "src"
                                  :test-suffix "_test.go")

#+END_SRC
**** treesitter

#+begin_src emacs-lisp
;; (use-package treesit-auto
;;   :ensure (:wait t)
;;   :demand t
;;   :custom
;;   (treesit-auto-install 'prompt)
;;   :config
;;   (setq treesit-auto-langs '(javascript typescript tsx css html))
;;   (treesit-auto-add-to-auto-mode-alist '(javascript typescript tsx css html))
;;   (global-treesit-auto-mode))
#+end_src
