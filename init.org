#+TITLE: nemaks's config (2)
#+AUTHOR: Quentin Burgess (quentin.burgess@frafos.com)
#+DESCRIPTION: Quick summary of tasks for nemaks second gen
#+STARTUP: show2levels
#+OPTIONS: toc:2

Thanks

- [[https://github.com/progfolio/.emacs.d/tree/master][nice big ass config]]
- [[https://github.com/syl20bnr/spacemacs][spcemacs]] of course
- [[https://github.com/doomemacs/doomemacs][doomecas]] also
- stackoverflow
- DT' youtube videos
- [[https://ianyepan.github.io/posts/emacs-emojis/][nice tuto about emojis]]
- [[https://github.com/mickeynp/ligature.el/wiki#cascadia--fira-code][ligatures official doc]]
- [[https://www.rahuljuliato.com/posts/emacs-tab-bar-groups][better native tab-bar]]
- [[https://howardabrams.com/hamacs/][monster config]]
- [[https://github.com/jeremygooch/jeremacs][less monstruous but still huge]]
- [[https://www.patrickdelliott.com/emacs.d/][nicely assembled config]]

* WIP TODOs
:PROPERTIES:
:COOKIE_DATA: todo recursive
:END:
** TODO v1 [11/15] [73%]
:PROPERTIES:
:COOKIE_DATA: todo recursive
:END:
*** DONE claude-el
*** WIP LSP

*** WIP keybinding
- [ ] migrate global-set-key to :map
- [ ] migrate from :map to :general (+ which key)
*** IDEA treesitter (another attempt)
*** TODO drop neotree in favor of treemacs (reduce deps)
*** DONE early init
*** DONE elpa management
*** DONE key describe (helpful)
*** DONE UI [3/3]
**** DONE dashboard
**** DONE fonts / faces / emojies / ligatures
**** DONE other stuffs (windows, box)
*** DONE [fly/spell/*]check
*** DONE magit
*** DONE org
* how to use 

#+begin_example console
$ emacs -q -l ~/repo/perso/nemaks/emacs-init.el --init-directory=~/repo/perso/nemaks
#+end_example

** hook to emacs init

To use, please set the following into the earliest emacs loading file (`~/.emacs`, `~/.emacs/init.el`)

#+BEGIN_EXAMPLE emacs-lisp
;; ~/.emacs-init.el
(require 'org)
(org-babel-load-file
  (expand-file-name "init.org"
    "~/path/to/nemaks/")
)
#+END_EXAMPLE

** as systemctl service (aka emacsclient)

#+begin_example console
$ # Start the emacs daemon serivce for the user.
$ systemctl --user enable ./emacs.service
$ # Then access an instance.
$ emacsclient -nc 
#+end_example

** chemacs2

Multiple emacs version may coexist, thanks to [[ttps://github.com/plexus/chemacs2.git][chemacs2]] -

#+BEGIN_EXAMPLE console
  $ git clone https://github.com/plexus/chemacs2.git ~/.emacs.d
  (...)
  $ cat .emacs-profiles.el
  (("default"   . ((user-emacs-directory . "~/.emacs.legacy")))
   ("legacy" . ((user-emacs-directory . "~/repo/perso/doomeacs")))
   ("spacemacs"   . ((user-emacs-directory . "~/repo/perso/spacemacs"))))
  $ emacs --with-profile default
#+END_EXAMPLE


**  misc

*** build emacs 29

Quick helper

#+BEGIN_EXAMPLE console
  $ git clone https://github.com/emacs-mirror/emacs \
    --branch 29.1 \
    --single-branch \
    --depth 1
  $ cd emacs
  $ git submodule update --init --recursive
  $ apt update && apt install -y \
      libgccjit0  libgccjit-13-dev libharfbuzz-dev libjansson4 libmagickwand-dev libjansson-dev libtree-sitter-dev libxpm-dev libgif-dev libgnutls28-dev \
      texinfo \
      imagemagick imagemagick-6-common
  $ ./autogen.sh
  $ ./configure \
     --without-compress-install \
     --with-native-compilation \
     --with-mailutils \
     --with-pop \
     --with-modules \
     --with-tree-sitter \
     --with-x-toolkit=no \
     --with-x \
     --with-rsvg \
     --with-imagemagick \
     --with-threads \
     --with-cairo \
     --with-harfbuzz \
     --without-toolkit-scroll-bars \
     GCC=g++-10 CC=gcc-10
  $ make -k -j4
  $ sudo make install
#+END_EXAMPLE



*** flycheck-golangci-lint patch 

#+begin_src diff

# emacs.d/elap/30.2/flycheck-golangci-lint-20251203/flycheck-golangci-lint.el

-
- (if (and version (>= (car version) 2))
+ ;; (if (and version (>= (car version) 2))
        ;; v2.x: Use new format (without text output flag to avoid mixed output)
-    '("--output.checkstyle.path=stdout")
+    '("--output.checkstyle.path=stdout" "--output.text.path=/dev/null" "--show-stats=false" "--path-mode=abs")
-       v1.x or fallback: Use legacy format
-    '("--out-format=checkstyle")))
+      ;; v1.x or fallback: Use legacy format
+    ;;'("--out-format=checkstyle")))

#+end_src

* TODO the config [0/17]
:PROPERTIES:
:COOKIE_DATA: todo recursive
:END:
** early-init

emacs 27+ offer the ealy-init, allowing us to speed thing up at start time.

*** header

`early-init.el` header

#+begin_src emacs-lisp
;;; early-init.el --- Early Init File -*- lexical-binding: t; no-byte-compile: t -*-
;;; Code:
#+end_src

*** elpaca tweaks

Since we're using elpaca as our package manager, we add the following to early-init.el to prevent package.el from loading packages, prior to our init file loading.


#+BEGIN_SRC emacs-lisp
;; Do not attempt to load default package manager.
(setq package-enable-at-startup nil)
#+END_SRC

We configure elpaca to download packages per emacs version

#+BEGIN_SRC emacs-lisp
;; elpa dir per emacs version
(setq package-user-dir (locate-user-emacs-file
                        (concat
                         (file-name-as-directory "elpa")
                         emacs-version)))
#+END_SRC

*** speed things up

#+BEGIN_SRC emacs-lisp
;; Skip default.el loading.
(setq inhibit-default-init nil)
;; Do not report native comp async warnings as errors.
(setq native-comp-async-report-warnings-errors nil)
#+END_SRC

Skipping a bunch of regular expression searching in the file-name-handler-alist should improve start time.

#+begin_src emacs-lisp
;; skipping bunch of regex at start time
(defvar default-file-name-handler-alist
  file-name-handler-alist)
(setq file-name-handler-alist nil)
#+end_src

*** debug

Running this form will launch the debugger after loading a package.
This is useful for finding out when a dependency is requiring a package
(perhaps earlier than you want).
Use by tangling this block and launching Emacs with emacs --debug-init.

#+begin_src emacs-lisp
;; (unless (string-empty-p file)
;;   (eval-after-load file
;;     '(debug)))
#+end_src

Similarly, this variable will hit the debugger when a message matches its regexp.

#+begin_src emacs-lisp
;; (setq debug-on-message "")
#+end_src

Adding a variable watcher can be a useful way to track down initialization and mutation of a variable.

#+begin_src emacs-lisp
;; (add-variable-watcher 'org-capture-after-finalize-hook
;;                       (lambda (symbol newval operation where)
;;                         (debug)
;;                         (message "%s set to %s" symbol newval)))

;; (setq debug-on-error t)
#+end_src

*** gbc tweak

`gc-cons-threshold` (800 KB) and `gc-cons-percentage` (0.1) control when the Emacs garbage collector can kick in. Temporarily turning these off during init should decrease startup time. Resetting them afterward will ensure that normal  operations don’t suffer from a large GC periods.

The following is a table shows values from popular Emacs configurations.

| Distribution | gc-cons-threshold |
|--------------+-------------------|
| Doom         |          16777216 |
| Spacemacs    |         100000000 |
| Default      |            800000 |

#+BEGIN_SRC emacs-lisp
;; tmp disable GC for startup, then re-activating it
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 1)

(defun +nemaks/gc-after-focus-change ()
  "Run GC when frame loses focus."
  (run-with-idle-timer
   5 nil
   (lambda () (unless (frame-focus-state) (garbage-collect)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun +nemaks/better-init-values ()
  "Set GC value to some sensitive one."
  (run-with-idle-timer
   1 nil
   (lambda ()
     (setq file-name-handler-alist default-file-name-handler-alist
           gc-cons-threshold 50000000
           read-process-output-max (* 1024 1024)
           gc-cons-percentage 0.2)
     (message "gc-cons-threshold & file-name-handler-alist restored")
     (when (boundp 'after-focus-change-function)
       (add-function :after after-focus-change-function #'+nemaks/gc-after-focus-change))
     )))

;; enable gbc msg
(setq garbage-collection-messages t)

(add-hook 'emacs-startup-hook #'+nemaks/better-init-values)
#+END_SRC

*** UI tweaks

Modify GUI elements before we have a chance to peek.


Turning off these visual elements before UI initialization should speed up init.

#+BEGIN_SRC emacs-lisp
;; disables menubar
(push '(menu-bar-lines . 0) default-frame-alist)
;; disables toolbar
(push '(tool-bar-lines . 0) default-frame-alist)
;; disables vertical scrollbar
(push '(vertical-scroll-bars) default-frame-alist)
#+END_SRC

Prevent instructions on how to close an emacsclient frame.

#+BEGIN_SRC emacs-lisp
(setq server-client-instructions nil)
#+END_SRC

Implicitly resizing the Emacs frame adds to init time. Fonts larger than the system default can cause frame resizing, which adds to startup tim.e

#+BEGIN_SRC emacs-lisp
(setq frame-inhibit-implied-resize t)
#+END_SRC

Ignore X resources.

#+BEGIN_SRC emacs-lisp
(advice-add #'x-apply-session-resources :override #'ignore)
#+END_SRC

Silence ring bell.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function #'ignore)
#+END_SRC

Lets tune the UI to something more minimal.

#+BEGIN_SRC emacs-lisp
;; enable smooth scrolling
(pixel-scroll-precision-mode 1)
;; disables menubar
(menu-bar-mode -1)
;; disables toolbar
(tool-bar-mode -1)
;; disables scrollbar
(scroll-bar-mode -1)
;; Disable tooltips
(tooltip-mode -1)
;; Give some breathing room
(set-fringe-mode 10)
;; Set up the visible bell


(setq
 ;; no thanks
 inhibit-splash-screen t
 ;; don't use system file dialog
 use-file-dialog nil
 ;; don't show new tab button
 tab-bar-new-button-show nil
 ;; don't show tab close button
 tab-bar-close-button-show nil
 ;; don't show tab close button
 tab-line-close-button-show nil
)
#+END_SRC

Let's tune the system windows.

#+BEGIN_SRC emacs-lisp
;; undecorate windows
;; this should be called before toggle-frame-maximized
(set-frame-parameter nil 'undecorated t)
(set-frame-parameter nil 'internal-border-width 0)
(add-to-list 'default-frame-alist '(undecorated . t))
(add-to-list 'default-frame-alist '(internal-border-width . 0))
#+END_SRC

Set a few fonts.

#+BEGIN_SRC emacs-lisp
;; Set fonts.
(push '(font . "Fira Code Retina") default-frame-alist)
(set-face-font 'default "Fira Code Retina")
(set-face-font 'variable-pitch "Fira Code Retina")
(copy-face 'default 'fixed-pitch)
;; NOTE: needed for emacsclient - fix reduced font size
(add-to-list 'default-frame-alist '(font . "Fira Code Retina"))
#+END_SRC

And start as a maximized window.

Taken from this [[https://emacsredux.com/blog/2020/12/04/maximize-the-emacs-frame-on-startup/][essay]], I figured I would start the initial frame automatically in fullscreen, but not any subsequent frames (as this could be part of the capturing system).

#+BEGIN_SRC emacs-lisp
;; Start as maximized window. (old implem)
;; (unless (frame-parameter nil 'fullscreen)
;;   (toggle-frame-maximized))
;; (add-to-list 'default-frame-alist '(fullscreen . maximized))


(add-to-list 'initial-frame-alist '(fullscreen . maximized))

#+END_SRC

But when capturing, I subsequently open smaller frames that shouldn’t be odd looking:

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
(add-to-list 'default-frame-alist '(ns-appearance . dark))
(add-to-list 'default-frame-alist '(undecorated-round . t))
#+end_src

*** let's "provide" the early init

#+BEGIN_SRC emacs-lisp
(provide 'early-init)
;;; early-init.el ends here
#+END_SRC

** TODO config [0/16]
*** init.el header

#+begin_src emacs-lisp
;;; init.el --- Personal configuration file -*- lexical-binding: t; no-byte-compile: t; -*-
;; NOTE: init.el is generated from init.org.  Please edit that file instead
#+end_src

*** package manager
**** elpaca

Let's install elpaca.
See the [[https://github.com/progfolio/elpaca#installer][repo instructions]] for more.

#+begin_src emacs-lisp
;;
;; Package manager (elpaca)
;;

(defvar elpaca-installer-version 0.11)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1 :inherit ignore
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (<= emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                  ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                  ,@(when-let* ((depth (plist-get order :depth)))
                                                      (list (format "--depth=%d" depth) "--no-single-branch"))
                                                  ,(plist-get order :repo) ,repo))))
                  ((zerop (call-process "git" nil buffer t "checkout"
                                        (or (plist-get order :ref) "--"))))
                  (emacs (concat invocation-directory invocation-name))
                  ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                        "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                  ((require 'elpaca))
                  ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (let ((load-source-file-function nil)) (load "./elpaca-autoloads"))))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+end_src

Let's also setup the ``use-package`` macro.

#+begin_src emacs-lisp
;; Install a package via the elpaca macro
;; See the "recipes" section of the manual for more details.
;; (elpaca example-package)

;; Install use-package support
(elpaca elpaca-use-package
  ;; Enable use-package :ensure support for Elpaca.
  (elpaca-use-package-mode))

;; NOTE:
;; package dl + loaded for cfg
;; (use-packageg general :ensure t :demand t)
;; package dl + lazy loaded
;; (use-packageg general :ensure t :after/:hook/:defer)
;; package no dl
;; (use-package genral :ensure nil ...)

;;When installing a package used in the init file itself,
;;e.g. a package which adds a use-package key word,
;;use the :wait recipe keyword to block until that package is installed/configured.
;;For example:
;;(use-package general :ensure (:wait t) :demand t)

;;Turns off elpaca-use-package-mode current declaration
;;Note this will cause evaluate the declaration immediately. It is not deferred.
;;Useful for configuring built-in emacs features.
;; (use-package emacs
;;   :ensure nil
;;   :config (setq ring-bell-function #'ignore))


(setq custom-file (expand-file-name "init.el" user-emacs-directory))
(add-hook 'elpaca-after-init-hook (lambda () (load custom-file 'noerror)))
#+end_src

And the use-feature one

#+begin_src emacs-lisp
(defmacro use-feature (name &rest args)
  "`use-package' for packages which do not require installation.
  See `use-package' for NAME and ARGS."
  (declare (indent defun))
  `(use-package ,name
     :ensure nil
     ,@args))
#+end_src

Few early packages

#+begin_src emacs-lisp
(elpaca-process-queues)
;;(elpaca-wait)
(use-package s
  :ensure (:wait t)
  :demand t)
(use-package f
  :ensure (:wait t)
  :demand t)
;; (elpaca-process-queues)
;; (elpaca-wait)
#+end_src

**** diminish

This package implements hiding or abbreviation of the modeline displays
(lighters) of minor-modes.  With this package installed, you can add
':diminish' to any use-package block to hide that particular mode in the
modeline.

#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure (:wait t)
  :demand t
  :config
  (diminish 'whitespace-mode)
  (diminish 'eldoc-mode)
  (diminish 'abbrev-mode)
  (diminish 'auto-revert-mode)
)
#+END_SRC

*** keybinding

**** general

Better key-bindings management.
See the [[https://github.com/noctuid/general.el][repo]] for more info.

#+begin_src emacs-lisp
;;
;; Key-Bindings
;;

;; Install general to manage keybinding.
(use-package general
  :ensure (:wait t)
  :demand t
  :config
  (general-auto-unbind-keys)

  ;; Setup M-m as the global leader key.
  (general-create-definer nemaks/leader-keys
    :state '(normal inset visual emacs)
    :keymap 'override
    :prefix "M-m" ;; Set leader.
    :global-prefix "M-m") ;; Access leader in insert mode.

  ;; Bugger management
  (nemaks/leader-keys
    "b" '(:ignore t :wk "Buffer")
    "b d"  '(nemaks--kill-current-buffer :wk "Kill current buffer")
    "b b" '(switch-to-buffer :wk "Switch buffer")
    "b i" '(ibuffer :wk "Ibuffer")
    "b k" '(kill-this-buffer :wk "Kill this buffer")
    "b M" '((lambda () (interactive) (switch-to-buffer "*Messages*"))
            :wk "Messages buffer")
    "b n" '(next-buffer :wk "Next buffer")
    "b p" '(previous-buffer :wk "Previous buffer")
    "b r" '(revert-buffer :wk "Reload buffer")
    "b s"  '(scratch-buffer :wk "Scratch buffer"))

  ;; Claude-code
  ;; Populated by 'claude-code.el'
  (nemaks/leader-keys
    "c" '(:ignore t :wk "ClaudeCode"))

  ;; Config management.
  ;; Used by 'restart-emacs'.
  (nemaks/leader-keys
    "C" '(:ignore t :wk "Config")
    "C r" '((lambda () (interactive)
              ;; (elpaca-process-queues)
              ;; (elpaca-wait)
              (load-file "~/repo/perso/nemaks/emacs-init.el"))
            :wk "Reload emacs config")
    "C o" '((lambda () (interactive)
              (find-file "~/repo/perso/nemaks/init.org"))
            :wk "Open emacs config"))


  ;; Error management.
  ;; namespace mostly used by 'flycheck' and 'f.el'
  (nemaks/leader-keys
  "e" '(:ignore t :wk "Error")
  "e b" '((lambda () (interactive) (setq compilations-scroll-output t)) :wk "Errror buffer to bottom")
  "e f" '((lambda () (interactive) (setq compilations-scroll-output 'first-error)) :wk "Errror buffer first error"))

  ;; LISP evaluation.
  ;; namespace mostly used by 'sudo-edit' and 'f.el'
  (nemaks/leader-keys
   "E" '(:ignore t :wk "Evaluate")
   "E b" '(eval-buffer :wk "Evaluate elisp in buffer")
   "E d" '(eval-defun :wk "Evaluate defun containing or after point")
   "E e" '(eval-expression :wk "Evaluate and elisp expression")
   "E l" '(eval-last-sexp :wk "Evaluate elisp expression before point")
   "E r" '(eval-region :wk "Evaluate elisp in region"))

  ;; file manipulation
  ;; namespace mostly used by 'sudo-edit' and 'f.el'
  (nemaks/leader-keys
    "f" '(:ignore t :wk "Files"))

  ;; file manipulation
  ;; namespace mostly used by 'magit'
  (nemaks/leader-keys
    "g" '(:ignore t :wk "Git"))

  ;; goto
  ;; namespace used 'consult-todo' & others
  (nemaks/leader-keys
    "G" '(:ignore t :wk "GoTo"))

  ;; help
  ;; namespace mostly used by 'helpful'
  (nemaks/leader-keys
    "h" '(:ignore t :wk "Help"))

  ;; lsp
  (nemaks/leader-keys lsp-mode
    "l" '(:ignore t :wk "LSP"))

  ;; Major mode
  ;; TODO: general majore-mode
  (nemaks/leader-keys
    "m" '(:ignore t :wk "Major mode"))

  ;; While org is the major mode
  (nemaks/leader-keys
    :major-modes '(org-mode)
    :keymap '(org-mode-map)
    "m" '(:ignore t :wk "Org mode")
    )

  ;; While go is the major mode
  (nemaks/leader-keys ;; go-mode
    :major-modes '(go-mode)
    :keymap '(go-mode-map)
    "m" '(:ignore t :wk "Go mode")
    )

  ;; Spelling
  ;; namespace mostly used by 'flyspell'
  (nemaks/leader-keys
    "s" '(:ignore t :wk "Spelling")
    "s d" '(nemaks/fd-switch-dictionary t :wk "Change dictionary")
    "s t" '(nemaks/flyspell-toggle t :wk "Toggle spell check")
    )

  ;; Toggling
  (nemaks/leader-keys
    "t" '(:ignore t :wk "Toggle")
    "t e" '(flycheck-list-errors :wk "Toggle errors list")
    ;; "t e" '(lsp-treemacs-errors-list :wk "Toggle errors list")
    "t L" '(display-fill-column-indicator-mode :wk "Toggle long lines visual limit")
    "t l" '(display-line-numbers-mode :wk "Toggle line numbers")
    "t n" '(neotree-toggle :wk "Toggle neotree file viewer")
    ;; "t s" '(nemaks/flyspell-toggle t :wk "Toggle spell check")
    "t T" '(visual-line-mode :wk "Toggle truncated lines")

    ;; Theming sub-category.
    "t t" '(:ignore t :wk "Theme")
    "t tl" '(load-theme :wk "Load theme")
    "t tn" '((lambda () (interactive) (load-theme 'doom-one t)) :wk "Load night theme")
    "t td" '((lambda () (interactive) (load-theme 'doom-one-light t)) :wk "Toggle day theme")
    )

  ;; tabs 
  (nemaks/leader-keys
    "T" '(:ignore t :wk "tabs")
    ;; "T n" '(load-theme :wk "Load theme")
    ;; "T n" '((lambda () (interactive) (load-theme 'doom-one t)) :wk "Load night theme")
    ;; "T d" '((lambda () (interactive) (load-theme 'doom-one-light t)) :wk "Toggle day theme")
    )

  ;; Windows
  (nemaks/leader-keys
    "w" '(:ignore t :wk "Windows")
    "w <left>" '(nemaks--buf-move-left :wk "Buffer move left")
    "w <down>" '(nemaks--buf-move-down :wk "Buffer move down")
    "w <up>" '(nemaks--buf-move-up :wk "Buffer move up")
    "w <right>" '(nemaks--buf-move-right :wk "Buffer move right")
    )
)
#+end_src

And a few keybindings that doesn't belong to any groups

#+begin_src emacs-lisp
(general-define-key
 "C-x <down>" '(bs-show :wk "BS show")
 "C-x 1" '(nemaks/toggle-maximize-buffer :wk "Maximize")
 "C-=" '(text-scale-increase :wk "Zoom in")
 "C--" '(text-scale-decrease :wk "Zoom out")
 "<C-wheel-down>" '(text-scale-increase :wk "Zoom in")
 "<C-wheel-up>" '(text-scale-decrease  :wk "Zoom out")

 ;; ctrl+pgup / ctrl+pgdn to change next/prev tab
 "<C-next>" '(tab-bar-switch-to-next-tab :wk "Next tab")
 "<C-prior>" '(tab-bar-switch-to-prev-tab :wk "Previous tab")
 )

#+end_src

**** helpful

For contextual information

#+BEGIN_SRC emacs-lisp
;; install an enriched help screen
(use-package helpful
  :ensure (:wait t)
  :demand t
  :after general
  :general
  (nemaks/leader-keys
    "h c" '(helpful-command :wk "helpful command")
    "h f" '(helpful-callable :wk "helpful callable")
    "h h" '(helpful-at-point :wk "helpful at point")
    "h F" '(helpful-function :wk "helpful function")
    "h v" '(helpful-variable :wk "helpful variable")
    "h k" '(helpful-key :wk "helpful key"))
  )
#+END_SRC
**** marginalia

The [[https://github.com/minad/marginalia][marginalia]] package gives a preview of M-x functions with a one line description,
extra information when selecting files, etc. Nice enhancement without learning any new keybindings.

#+begin_src emacs-lisp
(use-package marginalia
  :ensure (:wait t)
  :demand t
  :init
  (setq marginalia-annotators-heavy t)
  :config
  (add-to-list 'marginalia-command-categories '(project-find-file . file))
  (add-to-list 'marginalia-command-categories '(projectile-find-file . file))
  (marginalia-mode))
#+end_src

**** which-key

Which key for helpful emacs

#+BEGIN_SRC emacs-lisp
;; install which-key
(use-package which-key
  :ensure (:wait t)
  :demand t
  :diminish
  :init
  (setq which-key-enable-extended-define-key t)
  (which-key-mode 1) ;;; init is run every time at pre-config aka set var, invoke mode
  :config                ;;; config is run after the mode' loaded (via hook ?)
  (setq which-key-side-window-location 'bottom
        which-key-sort-order #'which-key-key-order
        which-key-allow-imprecise-window-fit nil
        which-key-sort-uppercase-first nil
        which-key-add-column-padding 1
        which-key-max-display-columns nil
        which-key-min-display-lines 6
        which-key-side-window-slot -10
        which-key-side-window-max-height 0.25
        which-key-idle-delay 0.3
        which-key-max-description-length 25
        which-key-allow-imprecise-window-fit nil
        which-key-separator " → " ))

;; document un-documented commonnly used shortcuts
(which-key-add-key-based-replacements
  "C-x P" "Popwin mgmt"
  "C-x t" "Tabs mgmt"
  ;; TODO: document other C-x smth
)
#+END_SRC

*** emacs defaults

#+begin_src emacs-lisp
;;Note this will cause evaluate the declaration immediately. It is not deferred.
;;Useful for configuring built-in emacs features.
(use-package emacs
  :ensure nil
  :demand t
  :config
  ;;Turns off elpaca-use-package-mode current declaration
  (setq ring-bell-function #'ignore)
  ;; Open symlink w/o  confirmation prompt.
  (setq vc-follow-symlinks t)
  ;; Load zsh alias
  (setq shell-command-switch "-ic")
  ;; set tab to 4 spaces width
  (setq-default tab-width 4)
  ;; always insert space
  (setq-default indent-tabs-mode nil)

  ;; Backup (aka ~/.#)
  ;; Delete excess backup versions silently
  (setq delete-old-versions -1)
  ;; make backups file even when in version controlled dir
  (setq vc-make-backup-files t)
  ;; which directory to put backups file
  (setq backup-directory-alist `(("." . "~/.emacs.d/backups")) )
  ;; transform backups file name
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)) )

  ;; use utf-8 by default
  (setq coding-system-for-read 'utf-8 )
  (setq coding-system-for-write 'utf-8 )
  ;; sentence SHOULD end with only a point.
  (setq sentence-end-double-space nil)

  (setq create-lockfiles nil) ;; no need to create lockfiles
  (setq enable-recursive-minibuffers t)
  (setq sentence-end-double-space nil)
  (defalias 'yes-or-no-p 'y-or-n-p) ;; life is too shor
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit) ;; escape quits everything

  ;; less noise when compiling elisp
  (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
  (setq load-prefer-newer t)

  ;; Hide commands in M-x which don't work in the current mode
  (setq read-extended-command-predicate 
        #'command-completion-default-include-p)

)
#+end_src

*** UI
**** bell

Enable visual bells

#+begin_src emacs-lisp
(setq visible-bell t)
#+end_src

**** faces

#+BEGIN_SRC emacs-lisp
;; Set the default face
(set-face-attribute 'default nil
                    :font "Fira Code Retina"
                    :height 120)

;; Set the fixed pitch face
(set-face-attribute 'fixed-pitch nil
                    :font "Fira Code Retina"
                    :height 100)

;; Set the variable pitch face
(set-face-attribute 'variable-pitch nil
                    :font "Fira Code Retina"
                    :height 295 :weight 'regular)
#+END_SRC

***** all-the-icons / dired

Seems [[https://github.com/rainstormstudio/nerd-icons.el][nerd icons]] may be a nice alternative.

#+BEGIN_SRC emacs-lisp
;; Please run M-x all-the-icons-install-fonts
(use-package all-the-icons
  :ensure (:wait t)
  :demand t
  :if (display-graphic-p))

;; (use-package dired-single) --> not found starting 30.0 ?

(use-package all-the-icons-dired
  :ensure (:wait t)
  :demand t
  :hook (dired-mode . (lambda () (all-the-icons-dired-mode t))))

(use-package all-the-icons-completion
  :ensure (:wait t)
  :demand t
  :after (all-the-icons)
  :init (all-the-icons-completion-mode))

(use-package dired-open
  :ensure (:wait t)
  :demand t
  :config
  ;; Doesn't work as expected!
  ;;(add-to-list 'dired-open-functions #'dired-open-xdg t)
  (setq dired-open-extensions '(("png" . "feh")
                                ("mkv" . "mpv"))))

(use-package dired-hide-dotfiles
  :ensure (:wait t)
  :demand t
  :hook (dired-mode . dired-hide-dotfiles-mode))
#+END_SRC

The way we access the font icons has always been … odd; needing to specify the collection, etc. I would like to come up with a better mechanism, so the following function abstracts that as I figure out a better solution.

***** nerd-icons

Used by the `nemaks-features` function ATM.

#+begin_src emacs-lisp
(use-package nerd-icons
  :ensure t
  :demand t)

(defun nemaks--font-icons (collection label &rest args)
  "Abstraction over `nerd-icons' project.
LABEL is a short icon description merged with COLLECTION to
identify an icon to use. For instance, 'faicon or 'octicon.

ARGS, a plist, contain the title, sizing and other information.

For instance:
  (font-icons 'faicon \"file\" :title \"File Management\")

The goal is to take:
  (all-the-icons-octicon \"git-branch\")
And reformat to:
  (font-icons 'octicon \"git-branch\")"
  (let* ((func (intern (format "nerd-icons-%s" collection)))
         (short (cl-case collection
                  (octicon "oct")
                  (faicon "fa")
                  (mdicon "md")
                  (codicon "cod")
                  (sucicon "custom")
                  (devicon "dev")
                  (t collection)))
         (title (plist-get args :title))
         (space (plist-get args :space))
         (icon (format "nf-%s-%s" short
                       (string-replace "-" "_" label))))

    ;; With the appropriate nerd-icons function name,
    ;; an expanded icon name, we get the icon string:
    (concat (apply func (cons icon args))
            (cond
             ((and title space) (concat (s-repeat space " ") title))
             (title             (concat " " title))))))

#+end_src

***** ligature

emacs 27+ "nativly" support ligature. See the
[[https://github.com/mickeynp/ligature.el/wiki#cascadia--fira-code][official doc]] for more info.

#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;
;; Ligature support ;;
;;;;;;;;;;;;;;;;;;;;;;

(use-package ligature
  :ensure (:wait t)
  :demand t
  :config
  ;; Enable the "www" ligature in every possible major mode
  (ligature-set-ligatures 't '("www"))
  ;; Enable traditional ligature support in eww-mode, if the
  ;; `variable-pitch' face supports it
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  ;; Enable all Cascadia and Fira Code ligatures in programming modes
  (ligature-set-ligatures 'prog-mode
                          '(;; == === ==== => =| =>>=>=|=>==>> ==< =/=//=// =~
                            ;; =:= =!=
                            ("=" (rx (+ (or ">" "<" "|" "/" "~" ":" "!" "="))))
                            ;; ;; ;;;
                            (";" (rx (+ ";")))
                            ;; && &&&
                            ("&" (rx (+ "&")))
                            ;; !! !!! !. !: !!. != !== !~
                            ("!" (rx (+ (or "=" "!" "\." ":" "~"))))
                            ;; ?? ??? ?:  ?=  ?.
                            ("?" (rx (or ":" "=" "\." (+ "?"))))
                            ;; %% %%%
                            ("%" (rx (+ "%")))
                            ;; |> ||> |||> ||||> |] |} || ||| |-> ||-||
                            ;; |->>-||-<<-| |- |== ||=||
                            ;; |==>>==<<==<=>==//==/=!==:===>
                            ("|" (rx (+ (or ">" "<" "|" "/" ":" "!" "}" "\]"
                                            "-" "=" ))))
                            ;; \\ \\\ \/
                            ("\\" (rx (or "/" (+ "\\"))))
                            ;; ++ +++ ++++ +>
                            ("+" (rx (or ">" (+ "+"))))
                            ;; :: ::: :::: :> :< := :// ::=
                            (":" (rx (or ">" "<" "=" "//" ":=" (+ ":"))))
                            ;; // /// //// /\ /* /> /===:===!=//===>>==>==/
                            ("/" (rx (+ (or ">"  "<" "|" "/" "\\" "\*" ":" "!"
                                            "="))))
                            ;; .. ... .... .= .- .? ..= ..<
                            ("\." (rx (or "=" "-" "\?" "\.=" "\.<" (+ "\."))))
                            ;; -- --- ---- -~ -> ->> -| -|->-->>->--<<-|
                            ("-" (rx (+ (or ">" "<" "|" "~" "-"))))
                            ;; *> */ *)  ** *** ****
                            ("*" (rx (or ">" "/" ")" (+ "*"))))
                            ;; www wwww
                            ("w" (rx (+ "w")))
                            ;; <> <!-- <|> <: <~ <~> <~~ <+ <* <$ </  <+> <*>
                            ;; <$> </> <|  <||  <||| <|||| <- <-| <-<<-|-> <->>
                            ;; <<-> <= <=> <<==<<==>=|=>==/==//=!==:=>
                            ;; << <<< <<<<
                            ("<" (rx (+ (or "\+" "\*" "\$" "<" ">" ":" "~"  "!"
                                            "-"  "/" "|" "="))))
                            ;; >: >- >>- >--|-> >>-|-> >= >== >>== >=|=:=>>
                            ;; >> >>> >>>>
                            (">" (rx (+ (or ">" "<" "|" "/" ":" "=" "-"))))
                            ;; #: #= #! #( #? #[ #{ #_ #_( ## ### #####
                            ("#" (rx (or ":" "=" "!" "(" "\?" "\[" "{" "_(" "_"
                                         (+ "#"))))
                            ;; ~~ ~~~ ~=  ~-  ~@ ~> ~~>
                            ("~" (rx (or ">" "=" "-" "@" "~>" (+ "~"))))
                            ;; __ ___ ____ _|_ __|____|_
                            ("_" (rx (+ (or "_" "|"))))
                            ;; Fira code: 0xFF 0x12
                            ("0" (rx (and "x" (+ (in "A-F" "a-f" "0-9")))))
                            ;; Fira code:
                            "Fl"  "Tl"  "fi"  "fj"  "fl"  "ft"
                            ;; The few not covered by the regexps.
                            "{|"  "[|"  "]#"  "(*"  "}#"  "$>"  "^="))
  ;; Enables ligature checks globally in all buffers. You can also do it
  ;; per mode with `ligature-mode'.
  (global-ligature-mode t)
  )
#+END_SRC

***** emojify

Thanks to that nice [[https://ianyepan.github.io/posts/emacs-emojis/][tuto]].

We've installed apple emoji following that [[https://github.com/samuelngs/apple-emoji-linux][repo]].

We're asking emacs to render symbol w/ apple ttf emoji.
#+begin_src emacs-lisp
(use-package emojify
  :ensure (:wait t)
  :hook
  (text-mode . emojify-mode) ;; bind to text-mode
  :config
  (when (member "Apple Color Emoji" (font-family-list))
    (set-fontset-font
     t 'symbol (font-spec :family "Apple Color Emoji") nil 'prepend))

  (setq
   ;; we want all emoji style
   emojify-display-style 'unicode
   emojify-prog-contexts  'both
   emojify-emoji-styles '(unicode github))
  ;; TODO: bind w/ general
  ;; ; override binding in any mode
  ;; (bind-key* (kbd "C-c .") #'emojify-insert-emoji))
)

#+end_src

**** doom

#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :ensure (:wait t)
  ;; :demand t
  ;; :defer 2
  :init
  (setq
   doom-modeline-minor-modes nil
   doom-modeline-buffer-encoding nil
   doom-modeline-major-mode-color-icon t
   doom-modeline-buffer-state-icon t
   doom-modeline-buffer-modification-icon t
   doom-modeline-lsp-icon t
   ;; Set VCS info max length
   doom-modeline-vcs-max-length 12
   ;; Enable word count
   doom-modeline-enable-word-count t
   ;; Disable time
   doom-modeline-time-icon nil
   ;; Show position %
   doom-modeline-percent-position t)
  (doom-modeline-mode 1)
  :config
  (column-number-mode 1)
  (display-battery-mode)
  :custom
  (doom-modeline-project-detection 'projectile "Use projectile to fetch the project")
  )

;; install nicer theme
;; need to run M-x nerd-icons-install-fonts
(use-package doom-themes
  :ensure (:wait t)
  :demand t
  :config
  ;; Global settings (defaults)
  (setq
   ;; if nil, bold is universally disabled
   doom-themes-enable-bold t
   ;; if nil, italics is universally disabled
   doom-themes-enable-italic t)

  (load-theme 'doom-one t)

  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)
  ;; Enable custom neotree theme (all-the-icons must be installed!)
  ;; (doom-themes-neotree-config)
  ;; or for treemacs users
  (setq doom-themes-treemacs-theme "doom-atom") ; use "doom-colors" for less minimal icon theme
  ;; (doom-themes-treemacs-config)
  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))
#+END_SRC

**** lines/columns

#+BEGIN_SRC emacs-lisp
;; lines numbers & hooks
(column-number-mode)
(global-display-line-numbers-mode t)
;; selectivly disable line numbers for some mode
(dolist (mode '(text-mode-hook
                org-mode-hook
				;; treemacs-mode-hook
                ;; neotree-mode-hook
                term-mode-hook
                dashboard-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda ()
                   (display-line-numbers-mode 0)
                   )))
#+END_SRC

Native to emacs 27.1+. Set indicator to 80 columns.

#+BEGIN_SRC emacs-lisp
;; set 100 col indicator
(setq
 display-fill-column-indicator-column 80
 fill-column 80)

;; selectivly enable visual column limit for some mode.
(dolist (mode '(org-mode-hook
                prog-mode-hook))
  (add-hook mode
            (lambda ()
              (display-fill-column-indicator-mode t)
              )))
#+END_SRC

Highlight text that extends beyond a certain column. See
[[https://github.com/jordonbiondo/column-enforce-mode][here]] for more info.

#+BEGIN_SRC emacs-lisp
(use-package column-enforce-mode
  :ensure (:wait t)
  :diminish
  :hook
  (prog-mode . column-enforce-mode) ;; bind to prog-mode
  (text-mode . column-enforce-mode) ;; bind to text-mode
  :config
  (setq column-enforce-column 100     ;; set highlight past 80 columns
        column-enforce-comments nil) ;; don't highlights comments
  )
#+END_SRC

**** landing dashboard

***** dad jokes
Stolen from [[https://howardabrams.com/hamacs/ha-dashboard.html][here]] - I like the idea :nerd_face:.

#+begin_src emacs-lisp
(use-package request
  :ensure (:wait t)
  :demand t
  :diminish
  :init
  (defvar nemaks-dad-joke nil "Holds the latest dad joke.")

  :config
  (defun nemaks-dad-joke ()
    "Display a random dad joke."
    (interactive)
    (message (nemaks--dad-joke)))

  (defun nemaks--dad-joke ()
    "Return string containing a dad joke from www.icanhazdadjoke.com."
    (setq nemaks-dad-joke nil)  ; Clear out old joke
    (nemaks--dad-joke-request)
    (nemaks--dad-joke-wait))

  (defun nemaks--dad-joke-wait ()
    (while (not nemaks-dad-joke)
      (sit-for 1))
    (unless nemaks-dad-joke
      (nemaks--dad-joke-wait))
    nemaks-dad-joke)

  (defun nemaks--dad-joke-request ()
    (request "https://icanhazdadjoke.com"
      :sync t
      :complete (cl-function
                 (lambda (&key data &allow-other-keys)
                   (setq nemaks-dad-joke data))))))


#+end_src

***** emacs native features

I would appreciate seeing if my Emacs installation has the features that I expect:

#+begin_src emacs-lisp
(defun nemaks-features (&optional non-iconic)
  "Simple display of features I'm most keen about.
  If NON-ICONIC is non-nil, return a string of text only."
  (interactive)

  (defun nemaks--feature-combo (container icon title)
    (nemaks--font-icons container icon :title title :height 1.3 :v-adjust -0.1))

  (defun nemaks--all-images ()
    (s-join "·"
            (-remove 'null
                     (list
                      (when (image-type-available-p 'gif)  "GIF")
                      (when (image-type-available-p 'svg)  "SVG")
                      (when (image-type-available-p 'jpeg) "JPG")
                      (when (image-type-available-p 'tiff) "TIFF")
                      (when (image-type-available-p 'webp) "WEBP")
                      (when (image-type-available-p 'png)  "PNG")))))

  (let* ((features
          (list
           ;; An either or ... at least for me:
           (when (eq (window-system) 'ns)
             (nemaks--feature-combo  'faicon "apple"   "MacOS"))
           (when (eq (window-system) 'pgtk)
             (nemaks--feature-combo  'faicon "xing"    "Gnome"))

           ;; Important to know if I have it:
           (when (and (fboundp 'native-comp-available-p)
                      (native-comp-available-p))
             (nemaks--feature-combo  'faicon "cog"     "Native Compilation"))
           (when (treesit-available-p)
             (nemaks--feature-combo  'faicon "tree"    "Tree Sitter"))
           (when (sqlite-available-p)
             (nemaks--feature-combo  'faicon "database" "Sqlite"))
           (when (gnutls-available-p)
             (nemaks--feature-combo  'faicon "expeditedssl" "TLS"))
           ;; Did we build with mail utilities? Check the command line
           ;; options we used to build Emacs:
           (when (or (string-search "with-mailutils" system-configuration-options)
                     (string-search "without-pop" system-configuration-options))
             (nemaks--feature-combo  'octicon "mail" "GNU Mail"))

           (when (fboundp 'make-xwidget)
             (nemaks--feature-combo  'mdicon "widgets" "XWidgets"))

           ;; This suffix of loadable module files will be nil if
           ;; modules are not supported:
           (when module-file-suffix  ; or (fboundp 'module-load)
             (nemaks--feature-combo 'faicon "th"       "Modules"))

           (when (json-available-p)
             (nemaks--feature-combo  'codicon "json"   "JSON"))
           (when (string-search "HARFBUZZ" system-configuration-features)
             (nemaks--feature-combo  'faicon "font"    "HARFBUZZ"))
           (when (string-search "DBUS" system-configuration-features)
             (nemaks--feature-combo  'faicon "bus"     "DBUS"))
           (nemaks--feature-combo  'faicon "picture-o" (nemaks--all-images))
           (when (fboundp 'imagemagick-types)
             (nemaks--feature-combo  'faicon "magic"   "ImageMagick"))))
         (results (s-join "  " (-remove 'null features))))

    (if (called-interactively-p)
        (message "Enabled features: %s" results)
      results)))
#+end_src

***** dashboard

Nice welcome screen. See the official
[[https://github.com/emacs-dashboard/emacs-dashboard][repo]] for more info.

#+BEGIN_SRC emacs-lisp
(use-package page-break-lines
  :ensure (:wait t)
  :diminish
  :demand t
)

;; nicer welcome screen
(use-package dashboard
  :ensure (:wait t)
  ;; :demand t
  :after (all-the-icons nerd-icons projectile page-break-lines s general)
  :init
  (defun nemaks-dashboard-version ()
    (let ((smaller-version (replace-regexp-in-string
                            (rx " (" (zero-or-more any) eol) "" (emacs-version))))
      (string-replace "\n" "" smaller-version)))

  ;; Tweak banner logo and title.
  (setq dashboard-banner-logo-title
        (format "Emacs with %s — %s"
                (if (and (fboundp 'native-comp-available-p)
                         (native-comp-available-p))
                    "with Native Compilation" "")
                (nemaks-dashboard-version)))
  ;; Disaply a random "dad joke" as footer message.
  (setq dashboard-footer-messages (list (nemaks--dad-joke)))

  ;; Set dashboard as initial buffer.
  (setq initial-buffer-choice 'dashboard-refresh-buffer)
  ;; Set projectile as project backend.
  (setq dashboard-projects-backend 'projectile)

  ;; horizontally center content
  (setq dashboard-center-content t)
  ;; verically center content
  (setq dashboard-vertically-center-content t)
  ;; enable cycle navigation between each section
  (setq dashboard-navigation-cycle t)

  ;; add icons to the widget headings and their items
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  (setq dashboard-set-navigator t)
  
  ;; close agenda buffers
  (setq dashboard-agenda-release-buffers t)
  ;; Disaply package & loadtime metrics.
  (setq dashboard-set-init-info t)

  (setq dashboard-icon-type 'all-the-icons) ;; use `all-the-icons' package
  (setq dashboard-display-icons-p t) ;; use `all-the-icons' package
  
  (setq dashboard-projects-switch-function 'counsel-projectile-switch-project-by-name)

  ;; IDEA: random cover in a dir
  (setq dashboard-startup-banner "/home/master/repo/perso/nemaks/logo/aum.xpm")
  (setq dashboard-image-banner-max-width 500)
  (setq dashboard-image-banner-max-height 500)
  (setq dashboard-image-extra-props '(:mask heuristic))

  (setq dashboard-items '(
                          (recents . 15)
                          (projects . 15)))

  (setq dashboard-item-shortcuts '(
                                   (recents   . "r")
                                   (projects  . "p")))

  (setq dashboard-item-names '(("Recent Files:"
                                . "Recently opened files:")))

  :when (not command-line-args-left)
  :config
  (dashboard-setup-startup-hook)
  (dashboard-modify-heading-icons '((recents . "file-text")))


  ;; Fonction pour ouvrir le dashboard dans un nouvel onglet
  (defun nemaks/new-tab-with-dashboard ()
    "Créer un nouvel onglet et ouvrir le dashboard."
    (interactive)
    (tab-new)
    (dashboard-refresh-buffer))
  
  ;; Remplacer le binding de création d'onglet
  (general-define-key
   "C-x t N" '(nemaks/new-tab-with-dashboard
               :wk "New tab with dashboard"))


  )

(add-hook 'dashboard-mode-hook
            (lambda ()
              (message "opt-in compilation features: %s" (nemaks-features))))
#+END_SRC

**** transparency

Native to emacs29+

#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(alpha-background . 90))
#+END_SRC

**** tree

Treemacs again ? Smth else ?


Let's use neotree, nicer than treemacs

#+begin_src emacs-lisp
(use-package neotree
  :ensure (:wait t)
  :demand t
  :config
  (setq neo-smart-open t
        neo-show-hidden-files t
        neo-window-width 25
        neo-window-fixed-size nil
        inhibit-compacting-font-caches t
        projectile-switch-project-action 'neotree-projectile-action)
  ;; truncate long file names in neotree
  (add-hook 'neo-after-create-hook
            #'(lambda (_)
                (with-current-buffer (get-buffer neo-buffer-name)
                  (setq truncate-lines t)
                  (setq word-wrap nil)
                  (make-local-variable 'auto-hscroll-mode)
                  (setq auto-hscroll-mode nil)))))
#+end_src

**** tabs

Native tab ? Or smth better ?

#+begin_src emacs-lisp
(use-feature tab-bar
  :custom
  (tab-bar-close-button-show nil "Dont' show the x button on tabs")
  (tab-bar-new-button-show   nil)
  ;;(tab-bar-show  nil "hide the tab bar. Use commands to access tabs.")
  (tab-bar-tab-hints t)
  (tab-bar-auto-width nil)
  (tab-bar-separator " ")
  (tab-bar-format '(tab-bar-format-tabs-groups
                    tab-bar-format-tabs
                    tab-bar-separator
                    tab-bar-format-add-tab))
  :general
  (general-define-key
   ;; TODO: move to M-m t ? 
    "C-x t b" '(tab-bar-history-back :wk "Backward history tab")
    "C-x t d" '(tab-bar-close-tab :wk "Close tab")
    "C-x t f" '(tab-bar-history-forward :wk "Forward history tab")
    "C-x t g" '(nemaks/tab-switch-to-group :wk "Switch to tab group")
    "C-x t H" '((lambda (arg) (interactive "p") (tab-bar-move-tab (- arg))) :wk "Move tab left")
    "C-x t h" '(tab-bar-switch-to-prev-tab :wk "Switch to previous tab")
    "C-x t l" '(tab-bar-switch-to-next-tab :wk "Switch to next tab")
    "C-x t L" '((lambda (arg) (interactive "p") (tab-bar-move-tab arg)) :wk "Move tab right")
    "C-x t n" '(tab-bar-switch-to-next-tab :wk "Switch to Next tab")
    ;; "C-x t N" '(tab-bar-new-tab :wk "New tab")

    "C-x t p" '(tab-bar-switch-to-prev-tab :wk "Prev tab")
    "C-x t P" '(nemaks/tab-group-from-project :wk "Group tabs per project")
    "C-x t r" '(tab-bar-rename-tab :wk "Rename tab")
    "C-x t t" '(tab-bar-switch-to-tab :wk "Switch to tab")
    "C-x t u" '(tab-bar-undo-close-tab :wk "Undo close tab")
    "C-x t O" '(tab-bar-close-other-tabs :wk "Close Other tabs")
    "C-x t w" '(tab-bar-move-tab-to-frame :wk "Move tab to frame"))
  )

;; First, tab-bar-tab-name-format-hints: I want to put some arrows around the hints number, and NOT show the buffer name.
(defun tab-bar-tab-name-format-hints (name _tab i)
  (if tab-bar-tab-hints (concat (format "»%d«" i) "") name))

(defun tab-bar-tab-group-format-default (tab _i &optional current-p)
  (propertize
   (concat (funcall tab-bar-tab-group-function tab))
   'face (if current-p 'tab-bar-tab-group-current 'tab-bar-tab-group-inactive)))

(defun nemaks/tab-group-from-project ()
  "Call `tab-group` with the current project name as the group."
  (interactive)
  (when-let* ((proj (project-current))
			  (name (file-name-nondirectory
					 (directory-file-name (project-root proj)))))
	(tab-group (format "[%s]" name))))

(tab-bar-mode t)

;; always open scratch in a fixed bugger.
(add-to-list 'display-buffer-alist
			 '("\\*scratch\\*"
			   (display-buffer-in-tab
                display-buffer-full-frame)
			   (tab-group . "[EMACS]")))

;; always open dashboard in a fixed bugger.
(add-to-list 'display-buffer-alist
			 '("\\*dashboard\\*"
			   (display-buffer-in-tab
                display-buffer-full-frame)
			   (tab-group . "[EMACS]")))

(defun nemaks/tab-switch-to-group ()
  "Prompt for a tab group and switch to its first tab.
Uses position instead of index field."
  (interactive)
  (let* ((tabs (funcall tab-bar-tabs-function)))
	(let* ((groups (delete-dups (mapcar (lambda (tab)
										  (funcall tab-bar-tab-group-function tab))
										tabs)))
		   (group (completing-read "Switch to group: " groups nil t)))
	  (let ((i 1) (found nil))
		(dolist (tab tabs)
		  (let ((tab-group (funcall tab-bar-tab-group-function tab)))
			(when (and (not found)
					   (string= tab-group group))
			  (setq found t)
			  (tab-bar-select-tab i)))
		  (setq i (1+ i)))))))

;; (custom-set-faces
;;   '(tab-bar
;; 	((t (:background "#232635" :foreground "#A6Accd"))))
;;   '(tab-bar-tab
;; 	((t (:background "#232635" :underline t))))
;;   '(tab-bar-tab-inactive
;; 	((t ( ;; :background "#232635" ;; uncomment to use this
;; 		  ;; :box (:line-width 1 :color "#676E95")
;; 		  ))))
;;   '(tab-bar-tab-group-current
;; 	((t (:background "#232635" :foreground "#A6Accd" :underline t))))
;;   '(tab-bar-tab-group-inactive
;; 	((t (:background "#232635" :foreground "#777")))))

#+end_src

*** completion

Generic auto-complete with boosted Ivy + company.

**** company

On-The-Fly typing completion + box

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure (:wait t)
  :demand t
  :diminish
  :config
  (setq
   ;; don't add any delay before trying to complete thing being typed
   ;; the call/response to gopls is asynchronous so this should have little
   ;; to no affect on edit latency
   company-idle-delay .1
   ;; start completing after a single character instead of 3
   company-minimum-prefix-length 2
   ;; show number
   company-show-numbers t
   ;; align fields in completions
   company-tooltip-align-annotations t
   ;; LSP compatibility
   company-backends '(company-capf))
  :hook
  ;; lang
  (prog-mode . company-mode)
  ;; org, markdown & co
  (text-mode . company-mode))

(global-set-key (kbd "TAB")
                #'company-indent-or-complete-common)

(use-package company-box
  :ensure (:wait t)
  :demand t
  :after company
  :diminish
  :hook (company-mode . company-box-mode))
#+END_SRC

**** ivy

See the [[https://github.com/abo-abo/swiper#ivy][repo (swiper#ivy)]].

#+begin_src emacs-lisp
;; Use 'ivy' instead of 'helm' (default).
(use-package ivy
  :ensure t
  :demand t
  :diminish ivy-mode
  ;; TODO: which-key
  :bind ;; TODO: convert to  geneal
  (
   :map ivy-minibuffer-map
   ("<left>" . ivy-backward-delete-char)
   ;; ("TAB" . ivy-alt-done)
   ;; ("C-l" . ivy-alt-done)
   ;; ("C-j" . ivy-next-line)
   ;; ("C-k" . ivy-previous-line)
   :map ivy-switch-buffer-map
   ("<left>" . ivy-backward-delete-char)
   ;; ("C-k" . ivy-previous-line)
   ;; ("C-l" . ivy-done)
   ;; ("C-d" . ivy-switch-buffer-kill)
   :map ivy-reverse-i-search-map
   ;; ("C-k" . ivy-previous-line)
   ;; ("C-d" . ivy-reverse-i-search-kill)
   ("<left>" . ivy-backward-delete-char))
  :config
  (setq ivy-use-virtual-buffers t
        ivy-count-format "%d/%d ")
  ;; (global-set-key (kbd "C-x b") 'ivy-switch-buffer)
  (ivy-mode 1)
  )

(setq ivy-use-selectable-prompt t)
#+end_src

**** ivy-prescient 

#+begin_src emacs-lisp
;; prescient.el is a library which sorts and filters lists of candidates
;; Conflict with smex, disabling sorting fix it
(use-package ivy-prescient
  :ensure (:wait t)
  :demand t
  :after ivy
  :init
  ;; Disable prescient sorting to coop w/ smex.
  (setq ivy-prescient-enable-sorting nil)
  :config
  (ivy-prescient-mode))
#+end_src

**** ivy-rich

#+begin_src emacs-lisp
(use-package ivy-rich
  :ensure t
  :demand t
  :after ivy
  :init  (ivy-rich-mode 1)
  :custom
  (ivy-virtual-abbreviate
   'full
   ivy-rich-switch-buffer-align-virtual-buffer t
   ivy-rich-path-style 'abbrev)
  :config
  (ivy-set-display-transformer
   'ivy-switch-buffer
   'ivy-rich-switch-buffer-transformer))

(use-package all-the-icons-ivy-rich
  :ensure t
  :demand t
  :after (ivy-rich) ;; all-the-icons
  :init (all-the-icons-ivy-rich-mode 1))
#+end_src

**** swiper

Enhance Ivy with [[https://github.com/abo-abo/swiper][swiper]].

#+begin_src emacs-lisp
(use-package swiper
  :ensure t
  :after (ivy general)
  :defer t
  :commands (swiper swiper-isearch)  ;; Autoload seulement quand appelé
  :general
  (general-define-key
   "C-s" '(swiper-isearch :wk "Search with swiper")))
#+end_src

**** counsel

Spread ivy to M-x with [[https://github.com/abo-abo/swiper#counsel][counsel (ivy#counsel)]].

#+begin_src  emacs-lisp
(use-package counsel
  :ensure (:wait t)
  :demand t
  :diminish
  :after (general ivy)
  :config
  (counsel-mode)
  :general
  (general-define-key
   "C-x b" '(counsel-switch-buffer :wk "Better file buffer")
   "C-x C-f" '(counsel-find-file :wk "Beffer find file")
   ;; "M-x" . '(counsel-M-x :wk "Powa")
   ;;)
   ;; (general-define-key
   ;; :map minibuffer-local-map
   ;;   "C-r" . '(counsel-minibuffer-history :wk "Reverse history search")
   )
  )

#+end_src

**** smex

Enhance ivy & other with frequently / most used invocation.
See [[https://github.com/nonsequitur/smex][the official repo]] for more.

#+BEGIN_SRC emacs-lisp
;; Persist history accross runs
(use-feature savehist
  :ensure nil
  :demand t
  :config
  (setq savehist-file
        (expand-file-name "savehist" user-emacs-directory))
  (setq history-length 1000)
  (setq savehist-additional-variables
        '(kill-ring search-ring regexp-search-ring))
  (savehist-mode 1))

(use-package smex
  :ensure t
  :demand t
  :after (ivy counsel)
  :init
  :config
  (smex-initialize)
  ;; Save history periodically.
  (smex-auto-update))
#+END_SRC

*** QoL

**** prompts

I prefer emacs to just ask y/n not yes/no

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
(setopt use-short-answers t)
#+end_src

**** shells

Prevent async shell command buffers from popping-up:

#+begin_src emacs-lisp
(add-to-list 'display-buffer-alist
  '("\\*Async Shell Command\\*.*" display-buffer-no-window))
#+end_src

**** regex

Fix emacs regex

#+begin_src emacs-lisp
(setq-default pcre-mode t)
#+end_src

**** buffers

Remember where I left off after killing a file

#+begin_src emacs-lisp
(save-place-mode 1)
#+end_src

When killing a buffer always pick the current buffer by default

#+begin_src emacs-lisp
(defun nemaks--kill-current-buffer ()
  "Kills the current buffer."
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'nemaks-kill-current-buffer)
#+end_src

When a file changes on disk, automatically reload its buffer silently

#+begin_src emacs-lisp
(global-auto-revert-mode 1)
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+end_src

***** auto-scroll *Compilation* buffer

#+begin_src emacs-lisp
;; scroll compilation buffer to first error
;; (setq compilation-scroll-output 'first-error)

;; scroll compilation buffer to end
(setq compilation-scroll-output t)
#+end_src

***** colored *Compilation* buffer.

#+BEGIN_SRC emacs-lisp
;; color compilation output
(require 'ansi-color)
(defun nemaks/colorize-compilation-buffer ()
  "Colorize the *compilation* buffer output"
  (ansi-color-apply-on-region compilation-filter-start (point)))
(add-hook 'compilation-filter-hook 'nemaks/colorize-compilation-buffer)
#+END_SRC

***** smooth scrolling

#+begin_src emacs-lisp
;; value greater than 100 gets rid of half page jumping
(setq scroll-conservatively 101)
;; how many lines at a time
(setq mouse-wheel-scroll-amount '(3 ((shift) . 3)))
;; accelerate scrolling
(setq mouse-wheel-progressive-speed t)
;; scroll window under mouse
(setq mouse-wheel-follow-mouse 't)
#+end_src

***** move buffer

Creating some functions to allow us to easily move windows (splits) around.  The following block of code was taken from buffer-move.el found on the EmacsWiki:
  https://www.emacswiki.org/emacs/buffer-move.el

#+BEGIN_SRC emacs-lisp
(require 'windmove)

;;;###autoload
(defun nemaks--buf-move-up ()
  "Swap the current buffer and the buffer above the split.
If there is no split, ie now window above the current one, an
error is signaled."
;;  "Switches between the current buffer, and the buffer above the
;;  split, if possible."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'up))
     (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No window above this one")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun nemaks--buf-move-down ()
"Swap the current buffer and the buffer under the split.
If there is no split, ie now window under the current one, an
error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'down))
     (buf-this-buf (window-buffer (selected-window))))
    (if (or (null other-win)
            (string-match "^ \\*Minibuf" (buffer-name (window-buffer other-win))))
        (error "No window under this one")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun nemaks--buf-move-left ()
"Swap the current buffer and the buffer on the left of the split.
If there is no split, ie now window on the left of the current
one, an error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'left))
     (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No left split")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))

;;;###autoload
(defun nemaks--buf-move-right ()
"Swap the current buffer and the buffer on the right of the split.
If there is no split, ie now window on the right of the current
one, an error is signaled."
  (interactive)
  (let* ((other-win (windmove-find-other-window 'right))
     (buf-this-buf (window-buffer (selected-window))))
    (if (null other-win)
        (error "No right split")
      ;; swap top with this one
      (set-window-buffer (selected-window) (window-buffer other-win))
      ;; move this one to top
      (set-window-buffer other-win buf-this-buf)
      (select-window other-win))))
#+END_SRC
***** maximize buffer

Instead of kill other via X-1. Stollen from spacemacs, sorry mom.

#+BEGIN_SRC emacs-lisp
(defun nemaks/toggle-maximize-buffer ()
  "Maximize buffer"
  (interactive)
  (save-excursion
	(if (and (= 1 (length (window-list)))
			 (assoc ?_ register-alist))
		(jump-to-register ?_)
      (progn
		(window-configuration-to-register ?_)
		(delete-other-windows)))))
#+END_SRC

***** pop-win

popwin is a popup window manager for Emacs which makes you free from the hell of annoying buffers such like *Help*, *Completions*, *compilation*, and etc.

#+BEGIN_SRC emacs-lisp
;; better buffer per name position mgmt
(use-package popwin
  :ensure (:wait t)
  :demand t
  :config
  (popwin-mode 1)
  (setq popwin:special-display-config
        '(
          ;; compilation at bottom
          ("*compilation*" :height 0.4 :noselect t :stick t)
          ;; termnial at bottom
          ("*terminal*" :position top :height 0.3 :noselect t)
          ("*shell*" :position top :height 0.3 :noselect t)
          ;; ("*Compile-Log*" :position bottom :height 0.3 )
          ;; Error right
          )))

(global-set-key (kbd "C-x P") popwin:keymap)
#+END_SRC

***** ominobox

Visual Studio like - see [[https://github.com/sebastiencs/omnibox][here]] for more.

#+BEGIN_SRC emacs-lisp
(use-package omnibox
  :ensure t
  :config
  ;; Disable omnibox-M-x as marginela offer nice completion out of the box.
  ;; (global-set-key (kbd "M-x") 'omnibox-M-x)
  ;; (omnibox-setup)
  )

;; better projectile switch via omnibox UI
(defun omnibox-projectile-switch-project nil
  """Spawn projectile switch project into an omnibox widget."""
  (interactive)
  (omnibox
   :prompt "Projects: "
   :candidates projectile-known-projects
   :action (lambda (candidate)
             (projectile-switch-project-by-name candidate))
   :title "Switch Project: "))

(defun omnibox-projectile-find-file nil
  """Spawn projectile find file into an omnibox widget."""
  (interactive)
  (let* ((omnibox-projectile-project-root (projectile-project-root)))
    (omnibox
     :prompt (format "[%s]: " (projectile-project-name))
     :candidates (projectile-current-project-files)
     :action (lambda (candidate)
               (find-file (expand-file-name candidate omnibox-projectile-project-root)))
     :title "Open File: ")))

;; bind default projectile-find-file to omnibox one
;; (setq projectile-switch-project-action 'omnibox-projectile-find-file)

;; counsel--M-x candidates sourced from source code
;; see https://github.com/abo-abo/swiper/blob/595d44264420d989e420351ea25b3c99528547c0/counsel.el#L856

;; ;; this is a wip
(defun omnibox-counsel-M-x ()
  """Spawm counsel-M-x into an omnibox widget."""
  (interactive)
  (omnibox
   :prompt "M-x: "
   :candidates (counsel--M-x-externs)
   ;; :history extended-command-history
   :detail 'omnibox--function-doc
   :action (lambda (candidate)
             (when candidate
               (counsel-M-x-action candidate)))
  :title "Omnibox counsel M-x"
  :require-match t))

;; (global-set-key (kbd "M-x") 'omnibox-counsel-M-x)
#+END_SRC

***** undo-tree
A better undo system. See the [[https://elpa.gnu.org/packages/undo-tree.html][official doc]] for more.

#+BEGIN_SRC emacs-lisp
;; install a better undo system
(use-package undo-tree
  :ensure t
  :diminish
  :config
  (setq undo-tree-history-directory-alist
        '(("." . "~/.emacs.d/undo")))
  (global-undo-tree-mode))
#+END_SRC

**** symbols

#+begin_src emacs-lisp
(global-prettify-symbols-mode 1)
#+end_src


**** code inlined TODOs highlight-ing

Highlight in-code TODOs

#+begin_src emacs-lisp
(use-package hl-todo
  :ensure (:wait t)
  :hook ((org-mode . hl-todo-mode)
         (prog-mode . hl-todo-mode)
         (text-mode . hl-todo-mode)
         (yaml-mode . hl-todo-mode)
         ;; (markdown-mode . hl-todo-mode)
         )
  :config
  (setq hl-todo-highlight-punctuation ":"
        hl-todo-keyword-faces
        `(("TODO"  warning bold)
          ("FIXME" error bold)
          ("HACK"  font-lock-constant-face bold)
          ("IDEA"  font-lock-keyword-face bold)
          ("LINK"  success bold)
          ("NOTE"  success bold))))
#+end_src

Suggests to bind some keys to hl-todo-next in order to jump from tag to tag, but the consult-todo implements that in a more visual way:

#+begin_src emacs-lisp
(use-package consult-todo
  :ensure (:wait t)
  :after (general)
  :init
  (defconst consult-todo--narrow
    '((?t . "TODO")
      (?f . "FIXME")
      (?h . "HACK")
      (?i . "IDEA")
      (?l . "LINK")
      (?n . "NOTE")))
  :general
  (nemaks/leader-keys
    "G t" '("GoTo ToDos" . consult-todo))
  )
#+end_src

**** rainbow delimiters

#+BEGIN_SRC emacs-lisp
;; install rainbow delimites
;; use M-x check-parens for parenthesis error
(use-package rainbow-delimiters
  :ensure (:wait t)
  :diminish
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
**** rainbow mode

Display the actual color as a background for any hex color value (ex. #ffffff).
The code block below enables rainbow-mode in all programming modes (prog-mode)
as well as org-mode, which is why rainbow works in this document.

#+BEGIN_SRC  emacs-lisp
(use-package rainbow-mode
  :ensure (:wait t)
  :diminish
  :hook
  ((prog-mode org-mode) . rainbow-mode))
#+END_SRC

**** find the bloody cursor

Large screen, lots of windows, so where is the cursor? While I used to use hl-line+,
I found that the prolific Protesilaos Stavrou introduced his Pulsar project is just what I need.
Specifically, I might loose the cursor and need to have it highlighted (using F8),
but also, this automatically highlights the cursor line with specific actions , like changing windows.

I can’t find the cursor, and don’t want to move it to see it, I can hit a key:

#+begin_src emacs-lisp
(use-package pulsar
  :ensure (:wait t)
  :demand t
  :bind ("<f8>" . pulsar-pulse-line) ;; TODO: convert to geneal
  :custom
  (pulsar-face 'pulsar-generic)
  (pulsar-delay 0.15)
  :config
  (dolist (built-in-function '(recenter-top-bottom
                               move-to-window-line-top-bottom
                               reposition-window
                               bookmark-jump
                               other-window
                               delete-window
                               delete-other-windows
                               forward-page
                               backward-page
                               scroll-up-command scroll-down-command
                               tab-new tab-close tab-next
                               org-next-visible-heading
                               org-previous-visible-heading
                               org-forward-heading-same-level
                               org-backward-heading-same-level
                               outline-backward-same-level
                               outline-forward-same-level
                               outline-next-visible-heading
                               outline-previous-visible-heading
                               outline-up-heading))
    (add-to-list 'pulsar-pulse-functions built-in-function))
(pulsar-global-mode 1))
#+end_src

**** sudo edit

#+BEGIN_SRC emacs-lisp
;; quickly sudo edit files
(use-package sudo-edit
  :ensure (:wait t)
  :demand t
  :after general
  :general
  (nemaks/leader-keys
    "f u" '(sudo-edit-find-file :wk "Sudo find file")
    "f U" '(sudo-edit :wk "Sudo edit file"))
)
#+END_SRC
**** reload-emacs

#+begin_src emacs-lisp
(use-package restart-emacs
  :after general
  :ensure t
  ;; :defer t
  :general
  (nemaks/leader-keys
    "C R" '(restart-emacs :wk "Restart Emacs"))
  )

#+end_src
*** org

Let's pimp 'org'

#+begin_src emacs-lisp
;;;;;;;;;;;;;;;;
;; ORG stuffs ;;
;;;;;;;;;;;;;;;;
#+end_src

Let's auto-toggle parent status.

#+begin_src emacs-lisp
(defun nemaks/org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-todo-log-states)   ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

(add-hook 'org-after-todo-statistics-hook #'nemaks/org-summary-todo)
#+end_src

Nicer checkbox.

#+BEGIN_SRC emacs-lisp
(defun nemaks/org-pretty-checkbox ()
  (add-hook 'org-mode-hook (lambda ()
                             "Beautify Org Checkbox Symbol"
                             (push '("[ ]" .  "☐") prettify-symbols-alist)
                             (push '("[X]" . "☑" ) prettify-symbols-alist)
                             (push '("[-]" . "❍" ) prettify-symbols-alist)
                             (prettify-symbols-mode)))
  (defface org-checkbox-done-text
    '((t (:foreground "#71696A")))
    "Face for the text part of a checked org-mode checkbox.")
  )
#+END_SRC

Nicer bullet point.

#+BEGIN_SRC emacs-lisp
(defun nemaks/org-pretty-bullet ()
  ;; replace list '-' w/ a '•'
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•")))))))
#+END_SRC

Better defaults.

#+BEGIN_SRC emacs-lisp
(defun nemaks/org-better-def ()
  (setq
   ;; show actually italicized text instead of /italicized text/
   ;; org-hide-emphasis-markers t
   ;; show ellipsis symbol
   ;; org-ellipsis " ▾"
   ;; auto indent
   org-startup-indented t
   ;;
   ;;
   org-fontify-done-headline t
   org-fontify-whole-heading-line t
   variable-pitch-mode 1
   ;; block parent if child not complete
   org-enforce-todo-dependencies t
   ;; org-fontify-quote-and-verse-blocks t
   ;; (org-indent-mode)
   ;; visual-line-mode 1


   ;; edit settings (recommended by org-modern)
   org-auto-align-tags nil
   org-tags-column 0
   org-catch-invisible-edits 'show-and-error
   org-special-ctrl-a/e t ;; special navigation behaviour in headlines
   org-insert-heading-respect-content t

  ;; styling, hide markup, etc. (recommended by org-modern)
   org-hide-emphasis-markers t
   org-pretty-entities t
   org-ellipsis "..."

   org-src-fontify-natively t ;; fontify source blocks natively
   org-highlight-latex-and-related '(native) ;; fontify latex blocks natively

   ;; agenda styling (recommended by org-modern)
   org-agenda-tags-column 0
   org-agenda-block-separator ?─
   org-agenda-time-grid
   '((daily today require-timed)
     (800 1000 1200 1400 1600 1800 2000)
     " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
   org-agenda-current-time-string
   "⭠ now ─────────────────────────────────────────────────"
   ))
#+END_SRC

Better statistics.

#+BEGIN_SRC emacs-lisp
(defun nemaks/org-better-stats ()
  (setq
   ;; auto recursive checkbox
   org-checkbox-hierarchical-statistics nil
   ;; auto recursive todos
   org-todo-hierarchical-statistics nil
   ;; auto what
   org-hierarchical-checkbox-statistics t
   )
  )
#+END_SRC

Let's provide org

#+begin_src emacs-lisp
(use-package org
  ;; :ensure (:wait t)
  ;; :defer t
  :demand t
  :after general
  :init

  (setq org-use-speed-commands t)
  (nemaks/org-better-stats)
  ;; (nemaks/org-pretty-checkbox) --> handled by org-modern
  (nemaks/org-pretty-bullet)
  (nemaks/org-better-def)

  ;; should disable latext math eval
  (setq org-use-sub-superscripts '{})

  ;; The following + electric indent to fix code block
  (setq org-edit-src-content-indentation 0)


  ;; todo setup
  (setq org-todo-keywords
        ;; it's extremely useful to distinguish between short-term goals and long-term projects
        '((sequence "IDEA(i)" "TODO(t)" "WIP(w)" "REVIEW(r)"  "|" "DONE(d)" "CANCELED")
          (sequence "TO-READ(r)" "READING(R)" "|" "HAVE-READ(d)")
          (sequence "PROJ(p)" "|" "COMPLETED(c)")))
  ;;:general
  ;; (nemaks/leader-keys )
  :hook
  ;; (org-mode . olivetti-mode)
  ;; (org-mode . variable-pitch-mode)
  (org-mode . visual-line-mode)
  (org-mode . (lambda () (electric-indent-local-mode -1))) ;; disable electric indentation

  :config
  (set-face-attribute 'org-ellipsis nil :inherit 'default :box nil)
  (add-to-list 'org-latex-packages-alist '("" "braket" t))
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((js . t)
     (emacs-lisp . t)
     (awk . t)))
  :general
  (nemaks/leader-keys org-mode-map
    "m a" '(org-agenda :wk "Org agenda")
    "m e" '(org-export-dispatch :wk "Org export dispatch")
    "m i" '(org-toggle-item :wk "Org toggle item")
    "m t" '(org-todo :wk "Org todo")
    "m B" '(org-babel-tangle :wk "Org babel tangle")
    "m T" '(org-todo-list :wk "Org todo list")
    "m b" '(:ignore t :wk "Tables")
    "m b -" '(org-table-insert-hline :wk "Insert hline in table")
    "m d" '(:ignore t :wk "Date/deadline")
    "m d t" '(org-time-stamp :wk "Org time stamp")
    )
  )
#+end_src

And a "smoll" function to coop with cookies statistics
Thanks [[https://emacs.stackexchange.com/questions/60710/is-there-any-way-of-getting-overview-statistics-for-all-checkboxes-in-a-given-or][you]].

#+begin_src emacs-lisp
(defun nemaks/org--aggregate-cookies ()
  (save-excursion
    (org-back-to-heading t)
    (let* ((prop (string-match "\\<aggregate\\>"
                               (or (org-entry-get nil "COOKIE_DATA") "")))
           )
      (if prop
          (let* ((counts (nemaks/org--aggregate-cookies-one-level))
                 (numerator (car counts))
                 (denominator (cadr counts))
                 (cookie-regex "\\[\\([0-9]*\\)/\\([0-9]*\\)\\]")
                 (new (format "[%d/%d]" numerator denominator)))
            (re-search-forward cookie-regex (line-end-position) t)
            (if (match-beginning 0)
                (progn
                  (setq beg (match-beginning 0)
                        ndel (- (match-end 0) beg))
                  (goto-char beg)
                  (insert new)
                  (delete-region (point) (+ (point) ndel))
                  ))))
      (if (org-up-heading-safe)
          (nemaks/org--aggregate-cookies))
      )))

(defun nemaks/org--aggregate-cookies-one-level ()
  (save-excursion
    (let* ((current (point))
           (next (save-excursion (outline-next-heading) (point)))
           (numerator 0)
           (denominator 0)
           (cookie-regex "\\[\\([0-9]*\\)/\\([0-9]*\\)\\]")
           )
      (defun count-one ()
        (re-search-forward cookie-regex (line-end-position) t)
        (if (> (match-end 1) (match-beginning 1))
            `(,(string-to-number (match-string 1))
              ,(string-to-number (match-string 2)))
          (0 0 )))
      (while (> next current)
        (goto-char next)
        (setq current next
              next (save-excursion (org-forward-heading-same-level 1) (point))
              current_total (count-one)
              denominator (+ denominator (cadr current_total))
              numerator (+ numerator (car current_total))))

      `(,numerator ,denominator)
      )))

(add-hook 'org-checkbox-statistics-hook (function nemaks/org--aggregate-cookies))
#+end_src

**** org-modern

#+begin_src emacs-lisp
(use-package org-modern
  :ensure t
  ;; :defer t
  ;; :demand t
  :after org
  :config
  ;; Overwrite default bullets from org-modern
  (setq org-modern-fold-stars
        '(
          ("◉" . "●")
          ("●". "○")
          ("●". "◉")
          ("○" . "●")
          ("▸" . "▾"))
        )
  (global-org-modern-mode)
)
#+end_src

**** org-appear

Make invisible parts of Org elements appear visible.

See the [[https://github.com/awth13/org-appear][repo]] for more.

#+begin_src emacs-lisp
(use-package org-appear
  :ensure t
  ;; :defer t
  ;; :demand t
  :after org
  :hook
  (org-mode-hook . org-appear-mode)
  :config
  (setq org-appear-autolinks t) ;; expand link
  (setq org-appear-autokeywords t) ;; expand keywords
  )
#+end_src
**** org-bullet

See https://github.com/integral-dw/org-bullets or https://github.com/sabof/org-bullets.
But stopped working so fuck it.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :disabled t
  :ensure t
  ;; :defer t
  :demand t
  :after org
  :commands org-bullets-mode
  :hook (org-mode . org-bullets-mode)
  :custom
  (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●"))
  )
#+end_src

**** org-tempo

Useful when inserting code block into org files


| Typing the below + TAB | Expands to ...                          |
|------------------------+-----------------------------------------|
| <a                     | '#+BEGIN_EXPORT ascii' … '#+END_EXPORT  |
| <c                     | '#+BEGIN_CENTER' … '#+END_CENTER'       |
| <C                     | '#+BEGIN_COMMENT' … '#+END_COMMENT'     |
| <e                     | '#+BEGIN_EXAMPLE' … '#+END_EXAMPLE'     |
| <E                     | '#+BEGIN_EXPORT' … '#+END_EXPORT'       |
| <h                     | '#+BEGIN_EXPORT html' … '#+END_EXPORT'  |
| <l                     | '#+BEGIN_EXPORT latex' … '#+END_EXPORT' |
| <q                     | '#+BEGIN_QUOTE' … '#+END_QUOTE'         |
| <s                     | '#+BEGIN_SRC' … '#+END_SRC'             |
| <v                     | '#+BEGIN_VERSE' … '#+END_VERSE'         |

#+BEGIN_SRC emacs-lisp
(require 'org-tempo)

(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-confirm-babel-evaluate nil
      org-edit-src-content-indentation 0)
#+END_SRC

**** org-toc

#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :ensure t
  ;; :defer t
  :after org
  :commands toc-org-enable
  :init (add-hook 'org-mode-hook 'toc-org-enable))
#+END_SRC
**** olivetti-mode

#+begin_src emacs-lisp
(use-package olivetti
  :ensure (:wait t)
  ;; :defer t
  ;; :demand t
  :after org
  :diminish
  :config (setq olivetti-body-width 0.95)
  ;; :hook (org-mode . olivetti-mode)
)
#+end_src

*** IDEA latex
*** TODO IDE

#+begin_src emacs-lisp
;;;;;;;;;;;;;;;;
;; IDE stuffs ;;
;;;;;;;;;;;;;;;;
#+end_src

**** IDEA treesitter

#+begin_src emacs-lisp
(use-package treesit-auto
  :ensure t
  :demand t
  :custom
  (treesit-auto-install 'prompt)
  :config
  ;; Used languages.
  (setq treesit-auto-langs 
        '(bash c cpp css go html javascript json python rust sql toml tsx typescript yaml))
  
  ;; Enable tree-sitter modes.
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))

#+end_src
**** WIP LSP

Let's setup the famous `lsp-mode`

#+begin_src emacs-lisp
;;;;;;;;;;;;;;;;
;; LSP stuffs ;;
;;;;;;;;;;;;;;;;

(use-package lsp-mode
  :ensure (:wait t)
  :commands (lsp lsp-deferred)
  :custom
  (lsp-idle-delay 0.5)  
  ;; (lsp-log-io nil)      
  (read-process-output-max (* 1024 1024)) ;; 1MB

  ; Features
  ;; Disable yasnippet
  (lsp-enable-snippet nil)  
  ;; Disable file watcher.
  (lsp-enable-file-watchers nil)
  (lsp-keep-workspace-alive nil)
  (lsp-completion-provider :capf)
  

  ;; Diagnostics flycheck.
  (lsp-diagnostics-provider :flycheck)
  
  ;; Disable cubersum clients.
  (lsp-disabled-clients '(semgrep-ls))  ;; emacs-lisp-ls viré, pas nécessaire

  ;; UI
  (lsp-headerline-breadcrumb-enable t)
  (lsp-headerline-breadcrumb-segments
   '(path-up-to-project file symbols))

  (lsp-ui-doc-enable t)

  :init
  (setq lsp-keymap-prefix "M-m l")

  ;; :demand t
  :hook (
         (yaml-mode . lsp-deferred)
         ;; Activate LSP for prog-modes except emacs-lisp-mode
         ((prog-mode . (lambda ()
                         (unless (derived-mode-p 'emacs-lisp-mode)
                           (lsp-deferred)))))
         (lsp-mode . lsp-enable-which-key-integration))

  :config
  (lsp-headerline-breadcrumb-mode)
)
#+end_src

***** lsp-ui

The [[The lsp-ui project offers much of the display and interface to LSP. Seems to make the screen cluttered.][lsp-ui]] project offers much of the display and
interface to LSP.
Seems to make the screen cluttered, needs a few tweaks.

#+begin_src emacs-lisp
;; More incode LSP info
(use-package lsp-ui
  :ensure (:wait t)
  ;; :demand t
  :after ( lsp-mode general)
  ;; :defer t
  :commands lsp-ui-mode
  :config
  (progn
    ;; Enable inline documentation
    (setq lsp-ui-sideline-enable t)
    (setq lsp-ui-doc-position 'bottom))
  (add-hook 'lsp-after-open-hook 'lsp-enable-imenu)
  :general
  (nemaks/leader-keys
    :keymaps 'prog-mode-map
    "G m" '("imenu" . lsp-ui-imenu))
  )
#+end_src

***** lsp-ivy

#+begin_src emacs-lisp
;; NOTE: company-lsp deprecated in favor of company-capf + LSP
;; LSP + ivy
(use-package lsp-ivy
  :ensure (:wait t)
  ;; :demand t
  :after (lsp-mode ivy)
  ;; :defer t
  :commands
  lsp-ivy-workspace-symbol)
#+end_src

***** lsp-treemacs

#+begin_src emacs-lisp
(use-package lsp-treemacs
  :ensure (:wait t)
  ;; :demand t
  :after (lsp-mode)
  ;; :defer t
  :commands
  lsp-treemacs-errors-list)
#+end_src

***** DAP mode

#+begin_src emacs-lisp
;; optionally if you want to use debugger
(use-package  dap-mode
  :ensure t
  ;; :demand t
  ;; :defer t
  :after (lsp-mode))
;; (use-package dap-LANGUAGE) to load the dap adapter for your language
#+end_src

***** lsp-docker

See the [[https://github.com/emacs-lsp/lsp-docker/tree/master][repo]] for more info.
Disabled ATM. Let's look into it later.


#+begin_src emacs-lisp
(use-package 'lsp-docker
  :disabled t
  :ensure t
  :after lsp
  :conf
  (defvar lsp-docker-client-packages
    '(lsp-css lsp-clients lsp-bash lsp-go lsp-pylsp lsp-html lsp-typescript
      lsp-terraform lsp-clangd))

  (setq lsp-docker-client-configs
        '((:server-id bash-ls :docker-server-id bashls-docker :server-command "bash-language-server start")
          (:server-id clangd :docker-server-id clangd-docker :server-command "clangd")
          (:server-id css-ls :docker-server-id cssls-docker :server-command "css-languageserver --stdio")
          (:server-id dockerfile-ls :docker-server-id dockerfilels-docker :server-command "docker-langserver --stdio")
          (:server-id gopls :docker-server-id gopls-docker :server-command "gopls")
          (:server-id html-ls :docker-server-id htmls-docker :server-command "html-languageserver --stdio")
          (:server-id pylsp :docker-server-id pyls-docker :server-command "pylsp")
          (:server-id ts-ls :docker-server-id tsls-docker :server-command "typescript-language-server --stdio")))
  :init
  (lsp-docker-init-clients
   :path-mappings '(("path-to-projects-you-want-to-use" . "/projects"))
   :client-packages lsp-docker-client-packages
   :client-configs lsp-docker-client-configs)
  )
#+end_src
***** TODO languages
****** docker-mode

#+begin_src emacs-lisp
(use-package dockerfile-mode
  :ensure t
  :defer t)
#+end_src

****** go mod

- [[https://github.com/nsf/gocode/blob/master/emacs-company/README.md][company-go]]
- [[https://github.com/weijiangan/flycheck-golangci-lint][flycheck-golangci-lint]]
  require golang-ci obviously
- [[https://github.com/emacsorphanage/go-eldoc?search=1][go-eldoc]] allow to get meta info
  require `$ go get -u github.com/nsf/gocode`
- [[https://github.com/s-kostyaev/go-fill-struct][go-fill-struct]]
  require `$ go get -u github.com/davidrjenni/reftools/cmd/fillstruct`
- [[https://github.com/s-kostyaev/go-gen-test][go-gen-test]]
  require `$ go get -u github.com/cweill/gotests/...`

TLDR:

#+begin_src shell
$ go -u install \
  # golangci lint
  github.com/golangci/golangci-lint/v2/cmd/golangci-lint@v2.4.0
  # go mod deps
  golang.org/x/tools/gopls@latest \
  # go-eldoc
  github.com/nsf/gocode@latest \
  # go-fill-struct
  github.com/davidrjenni/reftools/cmd/fillstruct@latest \
  # go-gen-test
  github.com/cweill/gotests/gotests@latest \
  # go-tag
  github.com/fatih/gomodifytags@latest \
  # stricter go fmt
  mvdan.cc/gofumpt@latest
#+end_src

#+BEGIN_SRC emacs-lisp
;; install go support for company
(use-package company-go
  :ensure t
  :defer t
  :hook
  (go-mode-hook . (lambda ()
                    (set (make-local-variable 'company-backends) '(company-go))
                    (company-mode))))

;; install flycheck support for golangci-lint
(use-package flycheck-golangci-lint
  :ensure t
  :defer t
  :hook  (go-mode . flycheck-golangci-lint-setup)
  ;; :config
  ;; (setq
  ;;  flycheck-golangci-lint-config
  ;;  "/home/master/repo/sbc/src/make_src/golangci.yaml")
)

;; install func meta info
(use-package go-eldoc ;; Don't need to require, if you install by package.el
  :ensure t
  :hook (go-mode-hook . go-eldoc-setup)
  :init
  (set-face-attribute 'eldoc-highlight-function-argument nil
                      :underline t :foreground "green"
                      :weight 'bold))

(defun nemaks/go-mode-setup ()
  "Basic Go mode setup."
  ;; (add-hook 'before-save-hook #'lsp-format-buffer t t)
  (add-hook 'before-save-hook #'gofmt-before-save t t)
  (add-hook 'before-save-hook #'lsp-organize-imports t t))

(use-package go-mode
  :ensure t
  :defer t
  :mode "\\.go\\'"
  :after general
  :hook
  (go-mode . nemaks/go-mode-setup)
  :config
  ;; (add-hook 'go-mode-hook #'nemaks/go-mode-setup)

  ;; golang compat build tag
  ;; TODO: hook to lsp-go-mode
  (setq
   lsp-go-env '((GOFLAGS . "-tags=integration,e2e,nowatcher")))
  (progn ;; use flycheck, not flymake
    (setq lsp-prefer-flymake nil
          lsp-enable-indentation nil
          lsp-enable-on-type-formatting nil))
  (setq gofmt-command "gofumpt")
  :general
  (nemaks/leader-keys
    :major-modes '(go-mode)
    :keymap '(go-mode-map)
    "m r" '(go-rename :wk "Go rename"))
  )

;; install a test generator
(use-package go-gen-test
  :ensure t
  :defer t
  :after (general go-mode)
  :general
  (nemaks/leader-keys
    :major-modes '(go-mode)
    :keymap '(go-mode-map)
     "m tg" '(:ignore t :wk "Go test gen")
     "m tgg" '(go-gen-test-dwim)
     "m tge" '(go-gen-test-exported :wk "Go test exported")
     "m tga" '(go-gen-test-all :wk "Go test all"))
    )

;; install a struct filler
(use-package go-fill-struct
  :ensure t
  :defer t
  :after (general go-mode)
  :general
  (nemaks/leader-keys
    :major-modes '(go-mode)
    :gkeymaps '(go-mode-map)
    "m s" '(go-fill-struct :wk "Fill structure"))
  )

(use-package go-tag
  :ensure t
  :defer t
  :after (general go-mode)
  :general
  (nemaks/leader-keys
    :major-modes
   '(go-mode)
   :keymaps
   '(go-mode-map)
   "m t" '(:ignore t :wk "Go tag")
   "m t a" '(go-tag-add :wk "Add tag")
   "m t r" '(go-tag-remove :wk "Remove tag"))
  )

;; https://emacs-lsp.github.io/lsp-mode/page/lsp-gopls/#configuration
(setq lsp-go-analyses '((shadow . t)
                        (simplifycompositelit . :json-false)))

;; set golangci-lint
(defvar-local flycheck-local-checkers nil)
(defun +nemaks/flycheck-checker-get(fn checker property)
  (or (alist-get property (alist-get checker flycheck-local-checkers))
      (funcall fn checker property)))
(advice-add 'flycheck-checker-get :around '+nemaks/flycheck-checker-get)

(add-hook 'go-mode-hook (lambda()
                          (flycheck-golangci-lint-setup)
                          (setq flycheck-local-checkers '((lsp . ((next-checkers . (golangci-lint))))))))
#+END_SRC

****** yaml mod

#+begin_src emacs-lisp
(use-package yaml-mode
  :ensure t
  ;; :after (lsp)
  :defer t
  :mode (("\\.\\(yml\\|yaml\\)\\'" . yaml-mode)
         )
  ;; :hook
  :init (setq emojify-mode -1))
#+END_SRC

****** systemd-mode

Nice package for systemd file editing. See the official [[https://elpa.gnu.org/packages/systemd.html][doc]] for more info.

#+BEGIN_SRC emacs-lisp
(use-package systemd
  :ensure t
  :defer t
  :after general
  :init
  (setq systemd-use-company-p t)
  ;; (configuration-layer/package-used-p 'company)
  :general

  (nemacs/leader-keys
   :major-modes '(systemd-mode)
   :keymap '(systemd-mode-map)
   "m" '(:ignore t :wk "Systemd mode")
   "m d" '(systemd-doc-directives)
   "m o" '(systemd-doc-open)))
#+END_SRC

****** TODO python mod

****** TODO php mod

****** TODO c/c++ mod

****** TODO cmake
****** TODO SQL
****** TODO markdown + vmd
****** TODO rust mod
****** TODO toml mod

**** on the fly checkers

Various kind of on the flt error reporters.

#+begin_src emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;
;; on-the-fly checkers ;;
;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

***** flycheck

Flycheck is a modern on-the-fly syntax checking extension for GNU Emacs,
intended as replacement for the older Flymake extension which is part of GNU Emacs.

https://www.flycheck.org/en/latest/

#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :after (general)
  :diminish
  :init
  (global-flycheck-mode)
  :commands (flycheck-mode)
  ;; :hook (lsp-mode . flycheck-mode)
  :custom
  (flycheck-emacs-lisp-load-path 'inherit "necessary with alternatives to package.el")
  (flycheck-display-error-delay .3)
  :general
  (nemaks/leader-keys
    "e n" '(flycheck-next-error     :repeat t :wk "next")
    "e N" '(flycheck-next-error     :repeat t :wk "next")
    "e p" '(flycheck-previous-error :repeat t :wk "previous")
    "e P" '(flycheck-previous-error :repeat t :wk "previous")
    ;; "e b" '("error buffer"     . flycheck-buffer)
    "e c" '("clear"            . flycheck-clear)
    "e l" '("list all"         . flycheck-list-errors)
    "e g" '("goto error"       . counsel-flycheck)
    "e y" '("copy errors"      . flycheck-copy-errors-as-kill)
    "e s" '("select checker"   . flycheck-select-checker)
    "e ?" '("describe checker" . flycheck-describe-checker)
    "e h" '("display error"    . flycheck-display-error-at-point)
    "e e" '("explain error"    . flycheck-explain-error-at-point)
    "e H" '("help"             . flycheck-info)
    "e i" '("manual"           . flycheck-manual)
    "e V" '("verify-setup"     . flycheck-verify-setup)
    "e v" '("version"          . flycheck-verify-checker)
    "e E" '("enable checker"   . flycheck-enable-checker)
    "e x" '("disable checker"  . flycheck-disable-checker)
    "e t" '("toggle flycheck"  . flycheck-mode)
    "e T" '(lsp-treemacs-errors-list :wk "List error tree")
    )
  )
#+end_src

***** flycheck-package

`package-lint` integration for flycheck.

#+begin_src emacs-lisp
(use-package flycheck-package
  :ensure t
  :after (flychceck)
  :config (flycheck-package-setup)
  (add-to-list 'display-buffer-alist
               '("\\*Flycheck errors\\*"  display-buffer-below-selected (window-height . 0.15))))

#+end_src

***** flyspell

The `flyspell-prog-mode` checks for misspellings in comments.

#+begin_src emacs-lisp
(use-feature flyspell
  :hook
  (prog-mode . flyspell-prog-mode)
  (git-commit-mode . flyspell-prog-mode)
  (text-mode . flyspell-prog-mode)
  :general
  (nemaks/leader-keys
    "s b" '(flyspell-buffer :wk "Check buffer")
    "s n" '(flyspell-goto-next-error :wk "Go to next error")
    "s p" '(flycheck-popup-auto-correct-mode :wk "Toggle popup")
    "s r" '(flyspell-region :wk "Check region")
    "s s" '(flyspell-correct-at-point :wk "Correct at point")
    )
  )
#+end_src

Let's also set up flyspell pop-up for easier fixing

And let's try that one

#+begin_src emacs-lisp
(use-package flyspell-correct
  :ensure t
  :after (flyspell general)
  :general
  (nemaks/leader-keys
    "s B" '(flyspell-correct-wrapper :wk "Correct wrapper")
    "s P" '(flyspell-correct-at-point :wk "Correct at point")
    )
  )
#+end_src

#+begin_src emacs-lisp
(use-package flyspell-correct-popup
  :ensure t
  :commands (flyspell-correct-popup)
  :after (flyspell-correct)
  :init
  (setq flyspell-correct-interface #'flyspell-correct-popup))

;; auto load flyspell per buffer
(add-hook 'after-change-major-mode-hook 'nemaks/flyspell-on-for-buffer-type)

;; skip code block check
(add-to-list 'ispell-skip-region-alist '("^#+BEGIN_SRC emacs-lisp" . "^#+END_SRC"))

;; don't log message for each word
(setq flyspell-issue-message-flag nil)
(setq flyspell-popup-correct-delay 0.5)
#+end_src

And now let's define a few helpful functions.
All credit to the [[https://www.emacswiki.org/emacs/FlySpell][emacswiki]].

#+begin_src emacs-lisp
;; stollen from https://www.emacswiki.org/emacs/FlySpell, sorry mom
(defun nemaks/flyspell-on-for-buffer-type ()
  "Enable Flyspell appropriately for the major mode of the current buffer.  Uses `flyspell-prog-mode' for modes derived from `prog-mode', so only strings and comments get checked.  All other text-buffers get `flyspell-mode' to check all text.  If flyspell is already enabled, does nothing."
  (interactive)
  (if (not (symbol-value flyspell-mode)) ; if not already on
      (progn
        (if (derived-mode-p 'prog-mode)
            (progn
              (message "Flyspell on (code)")
              (flyspell-prog-mode)
              ;; (flyspell-popup-auto-correct-mode)
              )
          (if (derived-mode-p 'text-mode)
              ;; else
              (progn
                (message "Flyspell on (text)")
                (flyspell-mode 1)
                ;; (flyspell-popup-auto-correct-mode 1)
                )))
        )))

(defun nemaks/flyspell-toggle ()
  "Turn Flyspell on if it is off, or off if it is on.  When turning on, it uses `flyspell-on-for-buffer-type' so code-vs-text is handled appropriately."
  (interactive)
  (if (symbol-value flyspell-mode)
      (progn ; flyspell is on, turn it off
        (message "Flyspell off")
        (flyspell-mode -1))
                                        ; else - flyspell is off, turn it on
    (nemaks/flyspell-on-for-buffer-type)))

(defun nemaks/fd-switch-dictionary()
  (interactive)
  (let* ((dic ispell-current-dictionary)
         (change (if (string= dic "francais") "english" "francais")))
    (ispell-change-dictionary change)
    (message "Dictionary switched from %s to %s" dic change)
    ))
#+END_SRC

#+end_src

**** magit


#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;;;;;;
;; magit stuff ;;
;;;;;;;;;;;;;;;;;

(use-package sqlite3
  :ensure (:wait t)
  :demand t)

(defun nemaks/magit-display-buffer-pop-up-frame (buffer)
  "Create or update the magit status dedicated buffer window"
  (if (with-current-buffer buffer (eq major-mode 'magit-status-mode))
      (display-buffer buffer
                      '((display-buffer-reuse-window
                         display-buffer-pop-up-frame)
                        (reusable-frames . t)))
    (magit-display-buffer-traditional buffer)))

;; ✅ Force install transient before magit
(use-package transient
  :ensure t
  :demand t)

;; install magit for git management
(use-package magit
  :ensure (:wait t)
  :demand t
  :after (general projectile transient)
  :commands (magit-status magit-get-current-branch)
  :custom
  (magit-display-buffer-function #'
   ;; magit-display-buffer-same-window-except-diff-v1)
   nemaks/magit-display-buffer-pop-up-frame)
  :config
  ;; (magit-rebase-commit-arguments '("--format=%h %an %s"))
  (transient-bind-q-to-quit)
  :general
  (nemaks/leader-keys
    "g b"  '(magit-branch :wk "Git branch")
    "g B"  '(magit-blame  :wk "Git blame")
    "g c"  '(magit-clone    :wk "Git clone")
    "g f"  '(:ignore t :which-key "Git file")
    "g f f" '(magit-find-file :wk "Git find file")
    "g f h" '(magit-log-buffer-file :wk "Git log buffer fule")
    "g i"  '(magit-init :wk "Git init")
    "g L"  '(magit-list-repositories :wk "Git list repositories")
    "g m"  '(magit-dispatch :wk "Git dispatch")
    "g S"  '(magit-stage-file :wk "Git stage file")
    "g s"  '(magit-status :wk "Git status")
    "g U"  '(magit-unstage-file :wk "Git unstage file")
    )
)

(use-package magit-todos
  :ensure t
  :after (magit forge))
#+END_SRC

***** forge

Forge allow to fetch extra meta-data from github & gitlab.

See [[https://magit.vc/manual/forge/Token-Creation.html#Token-Creation][token creation]] and [[https://magit.vc/manual/ghub/Getting-Started.html#Getting-Started][getting started]].

TLDR:

#+BEGIN_EXAMPLE console
$ cat .authinfo
machine gitlab.com/api/v4 login [username]^forge password [token]
#+END_EXAMPLE

#+BEGIN_SRC  emacs-lisp
(use-package forge
  :ensure t
  ;; :demand t
  :after magit
  :config
  (add-to-list 'forge-alist
               '("gitlab.frafos.net" "gitlab.frafos.net/api/v4"
                 "gitlab.frafos.net" forge-gitlab-repository)))
(setq auth-sources '("~/.authinfo"))
#+END_SRC

**** projectile

#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;
;; projectile stuff ;;
;;;;;;;;;;;;;;;;;;;;;;

;; projects handler
(use-package projectile
  :ensure (:wait t)
  :demand t
  :after (general)
  :diminish
  :general
  (nemaks/leader-keys
    "p" '(projectile-command-map :wk "Projectile"))
  :config (add-to-list 'projectile-globally-ignored-directories "*node_modules")
  (add-to-list 'projectile-globally-ignored-directories "*vendor")
  (projectile-register-project-type 
   'go_make '("Makefile" "src" "etc")
   ;; :project-file '("Makefile", "src/go.mod" "src/go.sum", "src/vendor")
   ;; :compilation-dir "."
   :compile "make static"
   :configure "make tidy sync rvendor"
   ;; :install "make install DESTDIR=`mktemp -d`"
   :test "make test TEST_ARGS='-failfast' TEST_TIMEOUT=5s"
   :src-dir "src"
   :test-suffix "_test.go")
  (projectile-mode 1)
  :custom
  ((project-completion-system 'ivy))
  :init
  (when (file-directory-p "~/repo")
    (setq projectile-project-search-path '("~/repo")))
  (setq
   projectile-indexing-method 'alien
   projectile-enable-caching t
   projectile-switch-project-action #'projectile-dired))
#+END_SRC

Let's also setup counsel-projectile 

#+begin_src emacs-lisp
(use-package counsel-projectile
  :ensure t
  :demand t
  :diminish
  :after (counsel)
  :config (counsel-projectile-mode))
#+end_src

**** claude.el

Let's setup 'claude.el'

#+begin_src emacs-lisp
;;
;; claude.el stuffs
;;

;; Install monet emacs backend
(use-package monet
  :disabled t
  ;; :ensure t
  ;; :vc (:url "https://github.com/stevemolitor/monet" :rev :newest)
  :ensure (;; :wait t
                 :host github 
                 :repo "stevemolitor/monet")
  ;; :demand t 
  :defer t
  :general
  (nemaks/leader-keys 
    "c M" '((lambda () (interactive) (monet-mode t)) :wk "Load monet"))
  ;; :config
  ;; (monet-mode 1)
  ;; :hook 
  ;; (prog-mode . monet-mode)
  ;; (text-mode . monet-mode)
)

;; install required inheritenv dependency:
(use-package inheritenv
  ;; :ensure t
  :ensure (;; :wait t
                 :host github 
                 :repo "purcell/inheritenv")
  ;; :defer t
  :demand t
  ;; :vc (:url "https://github.com/purcell/inheritenv" :rev :newest)
  )

;; for eat terminal backend:
(use-package eat 
  :ensure t
  :demand t
  ;; :defer t
  )

;; install claude-code.el
(use-package claude-code 
  :disabled t
  ;; :ensure t
  :ensure (;; :wait t 
                 :host github 
                 :repo "stevemolitor/claude-code.el")
  ;; :vc (:url "https://github.com/stevemolitor/claude-code.el" :rev :newest)
  ;; :after (monet eat inheritenv)
  :defer t
  ;; :demand t
  :init
  (setq claude-code-terminal-backend 'eat)
  :config
  ;; optional IDE integration with Monet
  (monet-mode 1)
  (add-hook
   'claude-code-process-environment-functions #'monet-start-server-function)

  ;; (claude-code-mode)
  :bind-keymap
  ("M-m c" . claude-code-command-map)

  ;; Optionally define a repeat map so that "M" will cycle thru Claude auto-accept/plan/confirm modes after invoking claude-code-cycle-mode / C-c M.
  :bind
  (:repeat-map 
   my-claude-code-map ("M" . claude-code-cycle-mode))
  :hook 
  (prog-mode . claude-code-mode)
)

#+end_src

